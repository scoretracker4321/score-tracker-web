import 'package:flutter/material.dart';
import 'dart:convert';
import 'package:flutter/foundation.dart' show kIsWeb; // For platform detection
import 'dart:async';
import 'package:http/http.dart' as http; // For Node.js server interactions (web only)
import 'package:intl/intl.dart';
import 'package:uuid/uuid.dart';
import 'dart:math' as math; // Import for 'math'
import 'package:collection/collection.dart'; // For firstWhereOrNull extension
import 'dart:ui'; // Added for PlatformDispatcher

// For screenshot functionality (not directly used for shareable report link now, but kept for other uses)
import 'dart:ui' as ui;
import 'package:flutter/rendering.dart';
import 'package:flutter/services.dart';

// Conditional imports for mobile screenshot/share
import 'dart:io' as io; // For mobile/desktop platforms
import 'package:path_provider/path_provider.dart'; // For getTemporaryDirectory
import 'package:share_plus/share_plus.dart'; // For sharing files

// Conditional import for web (html.AnchorElement)
// Ensure you have an empty html_stub.dart file in your lib/ folder if not on web.
import 'dart:html' if (dart.library.io) 'package:score_tracker_app/html_stub.dart' as html;

// Firebase imports
import 'package:firebase_core/firebase_core.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_storage/firebase_storage.dart'; // Import Firebase Storage
import 'firebase_options.dart'; // IMPORTANT: This file is generated by `flutterfire configure`.

// Image Picker
import 'package:image_picker/image_picker.dart'; // Corrected import for ImagePicker

// Import the platform clipboard abstraction
import 'package:score_tracker_app/platform_clipboard.dart';

// Import the separate models file
import 'models.dart'; // Ensure AppErrorLog and SharedReport are defined here
import 'shared_report.dart'; // Import the ReportViewerPage

/// Global Firebase variables (initialized in main)
FirebaseApp? firebaseApp;
FirebaseFirestore? db; // Will be initialized after firebaseApp
FirebaseAuth? auth;
FirebaseStorage? storage; // Global Firebase Storage instance
String? currentUserId;
String? appId; // Application ID for Firestore paths

// Global variables provided by Canvas for Firebase configuration (for web only)
// IMPORTANT: Replace 'YOUR_MOBILE_APP_PROJECT_ID_HERE' with the projectId found in lib/firebase_options.dart
// NOTE: For the report viewer page to work with public data, this appId must be fixed to the Firebase project ID.
// This ensures that the report viewer can access the 'public' collection regardless of the current user's app ID context.
const String _appIdCanvas = String.fromEnvironment('APP_ID', defaultValue: 'scoretrackerapp-16051');

const String _firebaseConfigCanvas = String.fromEnvironment('FIREBASE_CONFIG', defaultValue: '''
{
  "apiKey": "AIzaSyAP8qZ4cSAoGwSli7w7Dhu5VYYZDvIPmbw",
  "authDomain": "scoretrackerapp-16051.firebaseapp.com",
  "projectId": "scoretrackerapp-16051",
  "storageBucket": "scoretrackerapp-16051.firebasestorage.app",
  "messagingSenderId": "405298057035",
  "appId": "1:405298057035:web:7ac87bcb391d65b60762ce",
  "measurementId": "G-K6L8DDM6GL"
}
''');
const String _initialAuthTokenCanvas = String.fromEnvironment('INITIAL_AUTH_TOKEN', defaultValue: '');

// URL for the Node.js server base (for web only)
const String nodeServerBaseUrl = 'http://localhost:3000';

/// Function to log errors to the Node.js server (Web only).
/// This helps in debugging issues encountered in the deployed web application.
Future<void> _logErrorToServer(dynamic error, StackTrace stackTrace, {String? customMessage}) async {
  if (!kIsWeb) {
    print('Error logging to server skipped: Only for web version.');
    return;
  }

  final errorLog = AppErrorLog(
    message: error.toString(),
    stackTrace: stackTrace.toString(),
    platform: kIsWeb ? 'Web' : io.Platform.operatingSystem,
    userId: auth?.currentUser?.uid,
    userEmail: auth?.currentUser?.email,
    timestamp: DateTime.now(),
    customMessage: customMessage,
  );

  try {
    final response = await http.post(
      Uri.parse('$nodeServerBaseUrl/log-error'),
      headers: {'Content-Type': 'application/json'},
      body: json.encode(errorLog.toMap()),
    );

    if (response.statusCode == 200) {
      print('Error log sent to server successfully.');
    } else {
      print('Failed to send error log to server: ${response.statusCode} - ${response.body}');
    }
  } catch (e) {
    print('Failed to send error log due to network/server issue: $e');
  }
}

/// Main entry point of the Flutter application.
/// Initializes Firebase and handles initial routing.
void main() async {
  WidgetsFlutterBinding.ensureInitialized(); // Ensure Flutter widgets are initialized

  // Set up Flutter error handling to log errors to the server (web)
  FlutterError.onError = (FlutterErrorDetails details) {
    FlutterError.presentError(details); // Present error to developer console
    _logErrorToServer(details.exception, details.stack ?? StackTrace.current, customMessage: 'FlutterError.onError');
  };

  // Set up platform dispatcher error handling for unhandled exceptions
  PlatformDispatcher.instance.onError = (Object error, StackTrace stack) {
    _logErrorToServer(error, stack, customMessage: 'PlatformDispatcher.instance.onError');
    return true; // Return true to indicate the error has been handled
  };

  // Initialize Firebase BEFORE running the app to prevent null `db` issues.
  try {
    if (kIsWeb) {
      print('Attempting to initialize Firebase for Web...');
      final Map<String, dynamic> firebaseConfigMap = json.decode(_firebaseConfigCanvas);
      firebaseApp = await Firebase.initializeApp(
        options: FirebaseOptions(
          apiKey: firebaseConfigMap['apiKey'] as String? ?? '',
          appId: firebaseConfigMap['appId'] as String? ?? '',
          messagingSenderId: firebaseConfigMap['messagingSenderId'] as String? ?? '',
          projectId: firebaseConfigMap['projectId'] as String? ?? '',
          authDomain: firebaseConfigMap['authDomain'] as String?,
          storageBucket: firebaseConfigMap['storageBucket'] as String?,
          measurementId: firebaseConfigMap['measurementId'] as String?,
        ),
      );
      appId = _appIdCanvas; // Use the Canvas-provided or overridden appId for web

      auth = FirebaseAuth.instanceFor(app: firebaseApp!);
      storage = FirebaseStorage.instanceFor(app: firebaseApp!);
      db = FirebaseFirestore.instanceFor(app: firebaseApp!); // Initialize db here
      print('DEBUG: FirebaseFirestore.instanceFor(app: firebaseApp!) initialized.');

      // Force anonymous sign-in for web to ensure public access
      await auth!.signInAnonymously();
      print('Firebase initialized successfully for Web. Signed in anonymously.');

    } else { // Mobile/Desktop platforms
      print('Attempting to initialize Firebase for Mobile...');
      firebaseApp = await Firebase.initializeApp(
        options: DefaultFirebaseOptions.currentPlatform, // Uses firebase_options.dart for mobile
      );
      appId = DefaultFirebaseOptions.currentPlatform.projectId; // Use the project ID from firebase_options.dart for mobile

      auth = FirebaseAuth.instanceFor(app: firebaseApp!);
      storage = FirebaseStorage.instanceFor(app: firebaseApp!);
      db = FirebaseFirestore.instanceFor(app: firebaseApp!); // Initialize db here
      print('DEBUG: FirebaseFirestore.instanceFor(app: firebaseApp!) initialized.');

      print('DEBUG: _initialAuthTokenCanvas length: ${_initialAuthTokenCanvas.length}');
      if (_initialAuthTokenCanvas.isNotEmpty) {
        print('DEBUG: Canvas Token found. Attempting custom sign-in.');
        try {
          // Attempt to sign in with the custom token provided by the Canvas environment
          await auth!.signInWithCustomToken(_initialAuthTokenCanvas);
          print('DEBUG: Signed in with custom token (Mobile Admin).');
        } catch (e, stack) {
          print('DEBUG: Error signing in with custom token: $e');
          _logErrorToServer(e, stack, customMessage: 'Mobile custom token sign-in failed');
          print('DEBUG: Falling back to anonymous sign-in for mobile.');
          // Fallback to anonymous sign-in if custom token fails (e.g., expired, invalid)
          await auth!.signInAnonymously();
        }
      } else {
        print('DEBUG: No Canvas Token found. Signing in anonymously (Mobile Guest).');
        // Sign in anonymously if no custom token is provided (standard guest mode)
        await auth!.signInAnonymously();
      }
      print('Firebase initialized successfully for Mobile.');
    }

    print('DEBUG: Firestore DB instance initialized: ${db != null}');
    print('DEBUG: App ID being used: $appId');

    // Listen for authentication state changes and update global user ID
    auth!.authStateChanges().listen((User? user) {
      if (user != null) {
        debugPrint('DEBUG: Auth State Changed: User is signed in! UID: ${user.uid}, Email: ${user.email}, Provider: ${user.providerData.isNotEmpty ? user.providerData[0].providerId : 'N/A'}');
        currentUserId = user.uid; // Update the global user ID
      } else {
        debugPrint('DEBUG: Auth State Changed: User is currently signed out!');
        currentUserId = null; // Clear the global user ID if signed out
      }
    }, onError: (error, stack) {
      debugPrint('DEBUG: Error in authStateChanges listener (main): $error');
      _logErrorToServer(error, stack, customMessage: 'Auth state listener error in main');
    });

  } catch (error, stack) {
    print('DEBUG: Error initializing Firebase: $error');
    _logErrorToServer(error, stack, customMessage: 'Firebase initialization failed');
    // If Firebase initialization fails, show a critical error screen and prevent app from running normally.
    runApp(MaterialApp(
      home: Scaffold(
        body: Center(
          child: Text('Failed to initialize app: $error\nCheck Firebase setup.', style: const TextStyle(color: Colors.red)),
        ),
      ),
    ));
    return; // Exit main if Firebase initialization failed
  }

  // Determine initial route based on URL query parameters (for web only)
  String? initialRoute = '/';
  String? initialReportId;
  if (kIsWeb) {
    final uri = Uri.parse(html.window.location.href);
    final reportId = uri.queryParameters['reportId'];
    if (reportId != null && reportId.isNotEmpty) {
      initialRoute = '/report_viewer'; // Set route name for report viewer
      initialReportId = reportId; // Store reportId for passing as argument
    }
  }

  // Now that Firebase is fully initialized and `db` is available, run the app.
  runApp(ScoreTrackerApp(initialRoute: initialRoute, initialReportId: initialReportId));
}

/// The root widget of the Score Tracker application.
class ScoreTrackerApp extends StatelessWidget {
  final String initialRoute;
  final String? initialReportId;

  const ScoreTrackerApp({
    super.key,
    required this.initialRoute,
    this.initialReportId,
  });

  @override
  Widget build(BuildContext context) {
    // `db` is guaranteed to be non-null when build is called due to `await` in main()
    return MaterialApp(
      title: 'Score Tracker',
      theme: ThemeData(
        scaffoldBackgroundColor: Colors.white,
        primarySwatch: Colors.lightBlue,
        appBarTheme: const AppBarTheme(backgroundColor: Colors.lightBlue),
        visualDensity: VisualDensity.adaptivePlatformDensity, // Adapts visual density for different platforms
      ),
      // Define application routes
      routes: {
        '/': (context) => const HomePage(), // Main home page
        '/report_viewer': (context) {
          // Retrieve reportId from initialReportId (from URL) or route arguments
          final String? reportId = initialReportId ?? ModalRoute.of(context)?.settings.arguments as String?;

          // Handle case where report ID is missing
          if (reportId == null || reportId.isEmpty) {
            return const Scaffold(
              body: Center(
                child: Text('Error: Report ID missing. Please use a valid report link.'),
              ),
            );
          }
          // Pass the reportId and the initialized Firestore instance to the ReportViewerPage
          return ReportViewerPage(reportId: reportId, firestore: db!);
        },
      },
      initialRoute: initialRoute, // Set the initial route for the app
    );
  }
}

/// Enum for different types of undoable actions.
enum UndoableActionType {
  scoreUpdate,
  addEntity,
  deleteEntity,
  // Add other types as needed for more comprehensive undo
}

/// Class to store information about an undoable action, including its type and relevant data.
class UndoableAction {
  final UndoableActionType type;
  final Map<String, dynamic> data; // Store relevant data to revert the action

  UndoableAction({required this.type, required this.data});
}

/// The main home page of the Score Tracker application.
class HomePage extends StatefulWidget {
  const HomePage({super.key});

  @override
  _HomePageState createState() => _HomePageState();
}

/// The state class for the HomePage widget.
class _HomePageState extends State<HomePage> with WidgetsBindingObserver {
  // Firebase instances, initialized from global variables in initState
  late final FirebaseFirestore _firestore;
  late final FirebaseAuth _auth;
  late final FirebaseStorage _storage;
  late final String _appId; // This is the projectId

  // User authentication and state variables
  String? _userId;
  String? _userEmail;
  bool _isAuthReady = false;

  // Firestore stream subscriptions to listen for real-time data updates
  StreamSubscription? _studentsSubscription;
  StreamSubscription? _winnersSubscription;
  StreamSubscription? _activityLogSubscription;
  StreamSubscription? _guestLinksSubscription; // Subscription kept for data integrity, but UI removed
  StreamSubscription? _sharedReportsSubscription; // Subscription for shared reports

  // Lists to hold data fetched from Firestore
  List<StudentGroup> _allStudentGroups = [];
  List<Winner> _allWinners = [];
  List<AppActivity> _allActivities = [];
  List<Map<String, dynamic>> _allGuestLinks = []; // Data kept, but UI for displaying guest links removed
  List<SharedReport> _allSharedReports = []; // List of all shared reports

  // UI state and controllers
  bool _isGuestMode = true; // Forced to true due to anonymous sign-in for simplicity
  final TextEditingController _guestClassIdController = TextEditingController(); // Used for manual class filter

  StudentGroup? editingItem;
  StudentGroup? historyVisibleItem;
  final scoreController = TextEditingController();
  final commentController = TextEditingController();
  String _selectedClassId = '7A'; // Current class filter for the main list, DEFAULT TO '7A'
  String _entityTypeFilter = 'All'; // Filter for students, groups, or all
  String _currentSortCriteria = 'name'; // Current sorting criteria for the main list
  bool _sortAscending = true; // Sorting order (ascending/descending)
  final Uuid uuid = Uuid(); // UUID generator for unique IDs

  final Set<String> _highlightedItemIds = {}; // Placeholder for future highlighting if needed

  String _leaderboardSelectedClass = ''; // Class filter for the general leaderboard
  String _selectWinnersSelectedClass = ''; // Class filter for selecting winners (declaration)
  int _dataVersion = 0; // Not currently used, but could be for data migration
  bool _sortByGrowthInWinners = false; // Sorting option for winners history display

  String _message = ''; // Message to display to the user (e.g., success/error)
  Timer? _messageTimer; // Timer to clear the message after a delay

  bool _showGrowthLeaderboard = false; // Toggle for showing growth leaderboard vs. regular list

  final List<UndoableAction> _undoStack = []; // Stack to store undoable actions for undo functionality

  int _filteredStudentsCount = 0; // Count of students after applying filters
  int _filteredGroupsCount = 0; // Count of groups after applying filters

  String _selectedAlphabetFilter = ''; // Alphabetical filter for names

  final GlobalKey _listKey = GlobalKey(); // Key for capturing screenshot of the main list

  List<String> _uniqueClassIds = []; // List of unique class IDs found in data

  // Predefined reasons for score updates
  final List<String> _scoreReasons = [
    "Class participation",
    "Following norms",
    "Violating norms",
    "Activity Performance",
    "Unhealthy behaviour",
    "Collaboration",
    "Custom",
  ];

  String? _selectedReasonForLeaderboard; // Selected reason for reason-based leaderboard

  final ImagePicker _picker = ImagePicker(); // Image picker instance for winner photos

  bool _showArchivedStudents = false; // Toggle for showing archived students/groups (for manage dialog logic)


  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this); // Add observer for app lifecycle changes

    // Initialize Firebase instances from global variables, which are guaranteed to be set by main()
    _firestore = db!;
    _auth = auth!;
    _appId = appId!;
    _storage = storage!;

    // Listen for authentication state changes to determine user ID and subscribe to data
    _auth.authStateChanges().listen((User? user) async {
      print('DEBUG: HomePage Auth State Changed: User: ${user?.uid ?? "null"}, Email: ${user?.email ?? "null"}');
      if (user != null) {
        if (user.providerData.isNotEmpty) {
          print('DEBUG: HomePage Auth State Changed: Provider ID: ${user.providerData[0].providerId}');
        } else {
          print('DEBUG: HomePage Auth State Changed: No provider data found.');
        }
      }

      if (mounted) {
        setState(() {
          _userId = user?.uid;
          _userEmail = user?.email;
          _isAuthReady = true; // Authentication is now ready

          _isGuestMode = true; // Force guest mode as we are using anonymous sign-in
        });
        // Subscribe to Firestore data only when authentication is ready and user ID is available
        if (_isAuthReady && _userId != null) {
          print('DEBUG: HomePage: Auth ready and user ID present. Subscribing to Firestore data.');
          _subscribeToFirestoreData();
        } else {
          print('DEBUG: HomePage: Auth not ready or user ID null. Not subscribing to Firestore data yet.');
        }
      }
    }, onError: (error, stack) {
      print('DEBUG: Error in authStateChanges listener (HomePage): $error');
      _logErrorToServer(error, stack, customMessage: 'Auth state listener error in HomePage');
      if (mounted) {
        _showMessage('Authentication error: $error', isError: true);
      }
    });

    // Initialize leaderboard and winner selection class filters to empty
    _leaderboardSelectedClass = '';
    _selectWinnersSelectedClass = '';
  }

  @override
  void dispose() {
    // Clean up controllers and stream subscriptions when the widget is disposed
    WidgetsBinding.instance.removeObserver(this);
    scoreController.dispose();
    commentController.dispose();
    _guestClassIdController.dispose();
    _studentsSubscription?.cancel();
    _winnersSubscription?.cancel();
    _activityLogSubscription?.cancel();
    _guestLinksSubscription?.cancel();
    _sharedReportsSubscription?.cancel();
    _messageTimer?.cancel();
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    // Trigger automatic backup when the app is detached or inactive (for web only)
    if ((state == AppLifecycleState.detached || state == AppLifecycleState.inactive)) {
      print('App is closing/inactive.');
      if (kIsWeb) {
        _triggerAutomaticBackupOnClose();
      } else {
        print('Automatic backup not implemented for mobile in this version.');
      }
    }
  }

  /// Displays a temporary message to the user, fading out after 3 seconds.
  void _showMessage(String message, {bool isError = false}) {
    _messageTimer?.cancel(); // Cancel any existing timer to show the new message immediately
    setState(() {
      _message = message;
    });
    _messageTimer = Timer(const Duration(seconds: 3), () {
      if (mounted) { // Only update state if the widget is still in the tree
        setState(() {
          _message = ''; // Clear the message after the timer
        });
      }
    });
  }

  /// Subscribes to real-time data updates from Firestore for students, winners, activity log, and guest links.
  void _subscribeToFirestoreData() {
    print('DEBUG: _subscribeToFirestoreData called. App ID: $_appId');
    print('DEBUG: Current User ID: $_userId');
    print('DEBUG: Is Guest Mode: $_isGuestMode');
    print('DEBUG: Initial _selectedClassId before subscription: $_selectedClassId');

    // Cancel existing student subscription to avoid duplicate listeners
    _studentsSubscription?.cancel();
    CollectionReference<Map<String, dynamic>> studentsCollection;

    // Always query the public students collection for all users (admin and guest)
    studentsCollection = _firestore
        .collection('artifacts')
        .doc(_appId) // Use the global appId (which is the projectId)
        .collection('public')
        .doc('data')
        .collection('students');
    print('DEBUG: Querying public/data/students for all users (admin and guest).');

    Query<Map<String, dynamic>> studentsQuery = studentsCollection;

    // Apply archive status filter for the main view (show non-archived by default)
    if (!_showArchivedStudents) { // This `_showArchivedStudents` is only used for the main list visibility
      studentsQuery = studentsQuery.where('isArchived', isEqualTo: false);
      print('DEBUG: Filtering out archived students for main view.');
    } else {
      print('DEBUG: Showing all students, including archived, for main view.');
    }

    // Apply class filter if selected for the main list
    if (_selectedClassId.isNotEmpty) {
      studentsQuery = studentsQuery.where('classId', isEqualTo: _selectedClassId);
      print('DEBUG: Filtering students by class: $_selectedClassId');
    } else {
      print('DEBUG: No class filter applied to students (viewing all classes).');
    }

    // Listen for student data changes
    _studentsSubscription = studentsQuery
        .snapshots()
        .listen((snapshot) {
      print('DEBUG: Received Firestore students snapshot with ${snapshot.docs.length} documents.');
      setState(() {
        _allStudentGroups = snapshot.docs
            .map((doc) {
          print('DEBUG: Processing document: ${doc.id} => ${doc.data()}');
          return StudentGroup.fromMap(doc.data(), id: doc.id);
        })
            .toList();

        // Update unique class IDs based on fetched data from ALL student groups (including archived)
        // This ensures the class filter dropdown contains all relevant classes
        _uniqueClassIds = _allStudentGroups.map((e) => e.classId).toSet().toList();
        _uniqueClassIds.sort(); // Sort class IDs alphabetically
        print('DEBUG: Unique Class IDs found: $_uniqueClassIds');

        // Adjust _selectedClassId if '7A' was set as default but is not found
        // This makes the default '7A' conditional on its existence in data.
        if (_selectedClassId == '7A' && !_uniqueClassIds.contains('7A')) {
          _selectedClassId = ''; // Fallback to 'All Classes' if '7A' does not exist
          print('DEBUG: Class "7A" not found, defaulting to "All Classes".');
        }

        // Adjust leaderboard and winners selected classes to ensure they are valid based on available classes
        if (!_uniqueClassIds.contains(_leaderboardSelectedClass) && _leaderboardSelectedClass.isNotEmpty) {
          _leaderboardSelectedClass = ''; // Clear if the selected class no longer exists
        }
        if (!_uniqueClassIds.contains(_selectWinnersSelectedClass) && _selectWinnersSelectedClass.isNotEmpty) {
          _selectWinnersSelectedClass = ''; // Clear if the selected class no longer exists
        }

        debugPrint('DEBUG: Groups updated from Firestore. Current selected class: $_selectedClassId. Total groups/students: ${_allStudentGroups.length}');
      });
    }, onError: (error, stack) {
      _showMessage('Error fetching groups: $error', isError: true);
      debugPrint('DEBUG: Error fetching groups: $error');
      _logErrorToServer(error, stack, customMessage: 'Firestore students snapshot error');
    });

    // Listen for winners data changes (always from public collection)
    _winnersSubscription?.cancel();
    _winnersSubscription = _firestore
        .collection('artifacts')
        .doc(_appId)
        .collection('public')
        .doc('data')
        .collection('winners')
        .snapshots()
        .listen((snapshot) {
      setState(() {
        _allWinners = snapshot.docs
            .map((doc) => Winner.fromMap(doc.data(), id: doc.id))
            .toList();
        debugPrint('DEBUG: Winners updated from Firestore. Total winners: ${_allWinners.length}');
      });
    }, onError: (error, stack) {
      _showMessage('Error fetching winners: $error', isError: true);
      debugPrint('DEBUG: Error fetching winners: $error');
      _logErrorToServer(error, stack, customMessage: 'Firestore winners snapshot error');
    });

    // Listen for activity log data changes (always from public collection)
    _activityLogSubscription?.cancel();
    _activityLogSubscription = _firestore
        .collection('artifacts')
        .doc(_appId)
        .collection('public')
        .doc('data')
        .collection('activityLog')
        .orderBy('timestamp', descending: true) // Order by timestamp for latest activities first
        .snapshots()
        .listen((snapshot) {
      setState(() {
        _allActivities = snapshot.docs
            .map((doc) => AppActivity.fromMap(doc.data(), id: doc.id))
            .toList();
        debugPrint('DEBUG: Activity Log updated from Firestore. Total activities: ${_allActivities.length}');
      });
    }, onError: (error, stack) {
      _showMessage('Error fetching activity log: $error', isError: true);
      debugPrint('DEBUG: Error fetching activity log: $error');
      _logErrorToServer(error, stack, customMessage: 'Firestore activityLog snapshot error');
    });

    // Listen for guest links data changes (always from public collection) - UI elements for these features have been removed.
    _guestLinksSubscription?.cancel();
    _guestLinksSubscription = _firestore
        .collection('artifacts')
        .doc(_appId)
        .collection('public')
        .doc('data')
        .collection('guestLinks')
        .snapshots()
        .listen((snapshot) {
      setState(() {
        _allGuestLinks = snapshot.docs.map((doc) => doc.data() as Map<String, dynamic>).toList();
        debugPrint('DEBUG: Guest Links updated from Firestore. Total guest links: ${_allGuestLinks.length}');
      });
    }, onError: (error, stack) {
      _showMessage('Error fetching guest links: $error', isError: true);
      debugPrint('DEBUG: Error fetching guest links: $error');
      _logErrorToServer(error, stack, customMessage: 'Firestore guestLinks snapshot error');
    });

    // New: Listen for shared reports data changes
    _sharedReportsSubscription?.cancel();
    _sharedReportsSubscription = _firestore
        .collection('artifacts')
        .doc(_appId)
        .collection('public')
        .doc('data')
        .collection('sharedReports')
        .snapshots()
        .listen((snapshot) {
      setState(() {
        _allSharedReports = snapshot.docs
            .map((doc) => SharedReport.fromMap(doc.data(), id: doc.id))
            .toList();
        debugPrint('DEBUG: Shared Reports updated from Firestore. Total shared reports: ${_allSharedReports.length}');
      });
    }, onError: (error, stack) {
      _showMessage('Error fetching shared reports: $error', isError: true);
      debugPrint('DEBUG: Error fetching shared reports: $error');
      _logErrorToServer(error, stack, customMessage: 'Firestore sharedReports snapshot error');
    });
  }

  /// Shows a dialog to choose whether to add a new student or a new group.
  void _showAddEntityDialog() async {
    // Ensure authentication is ready before proceeding with any data modification
    if (!_isAuthReady || _userId == null) {
      _showMessage('Please wait for authentication to complete.', isError: true);
      return;
    }

    final bool? isGroupChosen = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('What do you want to add?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false), // User chose Student
            child: const Text('Student'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(true), // User chose Group
            child: const Text('Group'),
          ),
        ],
      ),
    );

    if (isGroupChosen != null) {
      _showAddEditEntityForm(isGroupChosen); // Proceed to the add/edit form based on choice
    }
  }

  /// Shows a form for adding a new student/group or editing an existing one.
  void _showAddEditEntityForm(bool isGroup, {StudentGroup? itemToEdit}) async {
    final nameController = TextEditingController(text: itemToEdit?.name);
    // Initialize selected class for new entities with the current filter or null if empty
    String? selectedClassIdForNewEntity = itemToEdit?.classId ?? (_selectedClassId.isNotEmpty ? _selectedClassId : null);
    final newClassIdController = TextEditingController();
    List<StudentGroup> selectedMembers = [];
    bool isNewClassMode = false;

    // If editing a group, pre-select its current members for the UI
    if (itemToEdit != null && itemToEdit.isGroup && itemToEdit.memberIds != null) {
      selectedMembers = _allStudentGroups
          .where((s) => itemToEdit.memberIds!.contains(s.id))
          .toList();
    }

    // Identify students already part of other groups to prevent double-grouping for selection
    Set<String> alreadyGroupedStudentIds = {};
    for (var group in _allStudentGroups.where((group) => group.isGroup && group.id != itemToEdit?.id && (_selectedClassId.isEmpty || group.classId == _selectedClassId))) {
      if (group.memberIds != null) {
        alreadyGroupedStudentIds.addAll(group.memberIds!);
      }
    }

    await showDialog(
      context: context,
      builder: (_) => StatefulBuilder( // Use StatefulBuilder to allow internal state updates within the dialog
        builder: (context, setInnerState) {
          return AlertDialog(
            title: Text('${itemToEdit == null ? "Add" : "Edit"} ${isGroup ? "Group" : "Student"}'),
            content: SingleChildScrollView(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  // Name input field
                  TextField(
                    controller: nameController,
                    decoration: const InputDecoration(labelText: 'Enter name'),
                  ),
                  const SizedBox(height: 16),
                  // Class selection for new entities (only if adding a new entity)
                  if (itemToEdit == null)
                    Column(
                      children: [
                        if (!isNewClassMode) // Dropdown for existing classes or "Add New Class" option
                          DropdownButtonFormField<String?>(
                            decoration: const InputDecoration(
                              labelText: 'Select Class',
                              border: OutlineInputBorder(),
                              contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                            ),
                            // Set initial value, ensuring it's one of the unique class IDs or null
                            value: _uniqueClassIds.contains(selectedClassIdForNewEntity) ? selectedClassIdForNewEntity : null,
                            hint: const Text('Select existing or add new'),
                            items: [
                              const DropdownMenuItem(value: null, child: Text('No Class Selected')),
                              ..._uniqueClassIds.map((classId) {
                                return DropdownMenuItem(value: classId, child: Text(classId));
                              }).toList(),
                              const DropdownMenuItem(value: '__NEW_CLASS__', child: Text('Add New Class...')),
                            ],
                            onChanged: (newValue) {
                              setInnerState(() { // Update dialog state
                                if (newValue == '__NEW_CLASS__') {
                                  isNewClassMode = true;
                                  selectedClassIdForNewEntity = null; // Clear selection when switching to new class mode
                                } else {
                                  selectedClassIdForNewEntity = newValue;
                                }
                              });
                            },
                          ),
                        if (isNewClassMode) ...[ // Input field for new class ID when in new class mode
                          const SizedBox(height: 16),
                          TextField(
                            controller: newClassIdController,
                            decoration: const InputDecoration(
                              labelText: 'New Class ID',
                              hintText: 'e.g., 8B',
                              border: OutlineInputBorder(),
                            ),
                          ),
                          TextButton(
                            onPressed: () {
                              setInnerState(() { // Cancel new class mode
                                isNewClassMode = false;
                                newClassIdController.clear();
                                // Attempt to revert to the default selected class if applicable
                                selectedClassIdForNewEntity = _selectedClassId.isNotEmpty && _uniqueClassIds.contains(_selectedClassId) ? _selectedClassId : null;
                              });
                            },
                            child: const Text('Cancel New Class'),
                          ),
                        ],
                      ],
                    )
                  else // Display class for existing entities (read-only)
                    Padding(
                      padding: const EdgeInsets.symmetric(vertical: 8.0),
                      child: Text('Class: ${itemToEdit.classId}', style: const TextStyle(fontWeight: FontWeight.bold)),
                    ),
                  // Member selection for groups (only if adding/editing a group)
                  if (isGroup) ...[
                    const SizedBox(height: 16),
                    Text('Select Students for Group (Class: ${_selectedClassId.isEmpty ? "All" : _selectedClassId}):', style: const TextStyle(fontWeight: FontWeight.bold)),
                    const SizedBox(height: 8),
                    SizedBox(
                      height: 200, // Fixed height for member list to prevent overflow
                      width: double.maxFinite,
                      child: ListView(
                        children: _sortItems( // Sort available students for consistent display
                          _allStudentGroups
                              .where((s) =>
                          !s.isGroup && // Only show students (not other groups)
                              (_selectedClassId.isEmpty || s.classId == _selectedClassId) && // Filter by class
                              !alreadyGroupedStudentIds.contains(s.id)) // Exclude already grouped students
                              .toList(),
                        ).map((student) {
                          return StatefulBuilder( // Use StatefulBuilder for each checkbox to update independently
                            builder: (context, setInnerState) {
                              final isSelected = selectedMembers.contains(student);
                              return CheckboxListTile(
                                title: Expanded(
                                  child: Text(
                                    student.name,
                                    overflow: TextOverflow.ellipsis,
                                    maxLines: 1,
                                  ),
                                ),
                                value: isSelected,
                                onChanged: (bool? value) {
                                  setInnerState(() { // Update checkbox state
                                    if (value == true) {
                                      selectedMembers.add(student);
                                    } else {
                                      selectedMembers.remove(student);
                                    }
                                  });
                                },
                              );
                            },
                          );
                        }).toList(),
                      ),
                    ),
                  ],
                ],
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context), // Cancel button to close dialog
                child: const Text('Cancel'),
              ),
              ElevatedButton(
                onPressed: () async {
                  // Input validation checks
                  if (nameController.text.isEmpty) {
                    _showMessage('Name cannot be empty.', isError: true);
                    return;
                  }
                  if (isGroup && selectedMembers.isEmpty) {
                    _showMessage('Groups must have at least one member.', isError: true);
                    return;
                  }

                  String finalClassId;
                  if (itemToEdit == null) { // Logic for adding a new entity
                    if (isNewClassMode) {
                      finalClassId = newClassIdController.text.trim();
                      if (finalClassId.isEmpty) {
                        _showMessage('New Class ID cannot be empty.', isError: true);
                        return;
                      }
                    } else {
                      finalClassId = selectedClassIdForNewEntity ?? '';
                      if (finalClassId.isEmpty) {
                        _showMessage('Please select an existing class or enter a new one.', isError: true);
                        return;
                      }
                    }
                  } else { // Logic for updating an existing entity
                    finalClassId = itemToEdit.classId; // Class ID is fixed for existing items
                  }

                  if (itemToEdit == null) { // Add new entity
                    final newStudentGroup = StudentGroup(
                      name: nameController.text,
                      isGroup: isGroup,
                      score: 100, // Default initial score for new entities
                      history: [ScoreHistoryEntry(score: 100, timestamp: DateTime.now())], // Initial history entry
                      classId: finalClassId,
                      memberIds: isGroup ? selectedMembers.map((s) => s.id!).toList() : null,
                      isArchived: false, // New entities are not archived by default
                    );

                    try {
                      // Add to the public students collection in Firestore
                      CollectionReference targetCollection = _firestore
                          .collection('artifacts')
                          .doc(_appId)
                          .collection('public')
                          .doc('data')
                          .collection('students');

                      final docRef = await targetCollection.add(newStudentGroup.toMap());

                      // Add this action to the undo stack
                      _undoStack.add(UndoableAction(
                        type: UndoableActionType.addEntity,
                        data: {'id': docRef.id},
                      ));

                      print('Added ${isGroup ? "group" : "student"}: ${newStudentGroup.name}');
                      await _logActivity('Added ${isGroup ? "Group" : "Student"}', {'name': newStudentGroup.name, 'classId': newStudentGroup.classId});
                      Navigator.pop(context); // Close dialog upon successful addition
                    } catch (error, stack) {
                      _showMessage('Error adding entity: $error', isError: true);
                      print('DEBUG: Error adding entity: $error');
                      _logErrorToServer(error, stack, customMessage: 'Failed to add entity');
                    }
                  } else { // Update existing entity
                    final originalItemData = itemToEdit.toMap(); // Store original data for undo/revert

                    final updatedStudentGroup = StudentGroup(
                      id: itemToEdit.id,
                      name: nameController.text,
                      isGroup: isGroup,
                      score: itemToEdit.score,
                      history: itemToEdit.history,
                      classId: itemToEdit.classId,
                      memberIds: isGroup ? selectedMembers.map((s) => s.id!).toList() : null,
                      isArchived: itemToEdit.isArchived,
                    );

                    try {
                      // Update the existing document in the public students collection
                      CollectionReference targetCollection = _firestore
                          .collection('artifacts')
                          .doc(_appId)
                          .collection('public')
                          .doc('data')
                          .collection('students');

                      await targetCollection.doc(itemToEdit.id).update(updatedStudentGroup.toMap());

                      // Add to undo stack (store original data to revert to previous state)
                      _undoStack.add(UndoableAction(
                        type: UndoableActionType.deleteEntity, // Using delete type for simplicity to re-add original data
                        data: {'id': itemToEdit.id, 'data': originalItemData},
                      ));

                      print('Updated ${isGroup ? "group" : "student"}: ${updatedStudentGroup.name}');
                      await _logActivity('Updated ${isGroup ? "Group" : "Student"}', {'id': itemToEdit.id, 'name': updatedStudentGroup.name});
                      Navigator.pop(context); // Close dialog upon successful update
                    } catch (error, stack) {
                      _showMessage('Error updating entity: $error', isError: true);
                      print('DEBUG: Error updating entity: $error');
                      _logErrorToServer(error, stack, customMessage: 'Failed to update entity');
                    }
                  }
                },
                child: Text(itemToEdit == null ? 'Add' : 'Update'),
              ),
            ],
          );
        },
      ),
    );
  }

  /// Opens the add/edit form for an existing entity.
  void editEntity(StudentGroup item) {
    _showAddEditEntityForm(item.isGroup, itemToEdit: item);
  }

  /// Deletes a student or group after confirmation.
  void deleteEntity(String id, String name) async {
    // Ensure authentication is ready before proceeding
    if (!_isAuthReady || _userId == null) {
      _showMessage('Please wait for authentication to complete.', isError: true);
      return;
    }
    final bool confirm = await showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Confirm Deletion'),
        content: Text('Are you sure you want to delete "$name"? This action can be undone.'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false), // Cancel deletion
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(true), // Confirm deletion
            child: const Text('Delete'),
          ),
        ],
      ),
    ) ?? false; // Default to false if dialog is dismissed

    if (confirm) {
      try {
        CollectionReference targetCollection = _firestore
            .collection('artifacts')
            .doc(_appId)
            .collection('public')
            .doc('data')
            .collection('students');

        final docSnapshot = await targetCollection.doc(id).get();

        if (docSnapshot.exists) {
          final originalData = docSnapshot.data(); // Store original data for undo
          await targetCollection.doc(id).delete(); // Perform deletion

          // Add to undo stack to re-add the deleted document
          _undoStack.add(UndoableAction(
            type: UndoableActionType.deleteEntity,
            data: {'id': id, 'data': originalData},
          ));

          print('Deleted entity: $name');
          await _logActivity('Deleted Student/Group', {'id': id, 'name': name});
          _showMessage('"$name" deleted successfully. Click Undo to revert.');
        } else {
          _showMessage('Entity not found for deletion.', isError: true);
        }
      } catch (error, stack) {
        _showMessage('Error deleting entity: $error', isError: true);
        print('DEBUG: Error deleting entity: $error');
        _logErrorToServer(error, stack, customMessage: 'Failed to delete entity');
      }
    }
  }

  /// Toggles the archived status of a student or group.
  /// This function is primarily used internally by the `_showManageHiddenStudentsDialog`.
  void _toggleArchiveStatus(StudentGroup item) async {
    // Ensure authentication is ready
    if (!_isAuthReady || _userId == null) {
      _showMessage('Please wait for authentication to complete.', isError: true);
      return;
    }

    final bool newArchiveStatus = !item.isArchived;
    final String actionText = newArchiveStatus ? 'Archived' : 'Unarchived';

    print('DEBUG: Toggling archive status for ${item.name}. Current isArchived: ${item.isArchived}, New status: $newArchiveStatus');

    try {
      CollectionReference targetCollection = _firestore
          .collection('artifacts')
          .doc(_appId)
          .collection('public')
          .doc('data')
          .collection('students');

      await targetCollection.doc(item.id).update({'isArchived': newArchiveStatus});

      _showMessage('${item.name} $actionText successfully.');
      await _logActivity('$actionText Student/Group', {'id': item.id, 'name': item.name, 'isArchived': newArchiveStatus});
      print('DEBUG: ${item.name} $actionText successfully.');
    } catch (error, stack) {
      _showMessage('Error $actionText ${item.name}: $error', isError: true);
      print('DEBUG: Error $actionText ${item.name}: $error');
      _logErrorToServer(error, stack, customMessage: 'Failed to $actionText entity');
    }
  }

  /// Updates the score of a student or group and logs the history.
  void updateScore(String id, int currentScore, int change, String name, String reason, String? customComment) async {
    // Ensure authentication is ready
    if (!_isAuthReady || _userId == null) {
      _showMessage('Please wait for authentication to complete.', isError: true);
      return;
    }
    final newScore = currentScore + change;
    final newHistoryEntry = ScoreHistoryEntry(score: newScore, timestamp: DateTime.now(), reason: reason, customComment: customComment);

    try {
      CollectionReference targetCollection = _firestore
          .collection('artifacts')
          .doc(_appId)
          .collection('public')
          .doc('data')
          .collection('students');

      final docRef = targetCollection.doc(id);

      final docSnapshot = await docRef.get();
      // Retrieve original history and score for undo functionality
      final originalHistory = ((docSnapshot.data() as Map<String, dynamic>?)?['history'] as List<dynamic>?)
          ?.map((e) => ScoreHistoryEntry.fromMap(e as Map<String, dynamic>))
          .toList() ?? [];
      final originalScore = ((docSnapshot.data() as Map<String, dynamic>?)?['score'] as int?) ?? 100;

      // Update score and add new history entry using arrayUnion
      await docRef.update({
        'score': newScore,
        'history': FieldValue.arrayUnion([newHistoryEntry.toMap()]),
      });

      // Add to undo stack (stores enough info to revert the exact score change)
      _undoStack.add(UndoableAction(
        type: UndoableActionType.scoreUpdate,
        data: {
          'id': id,
          'oldScore': originalScore, // The score before this specific update
          'newEntryTimestamp': newHistoryEntry.timestamp.toIso8601String(), // Timestamp of the entry to remove
        },
      ));

      print('Updated score for $name to $newScore with reason: $reason');
      await _logActivity('Updated Score', {
        'id': id,
        'name': name,
        'oldScore': currentScore,
        'newScore': newScore,
        'change': change,
        'reason': reason,
        'customComment': customComment,
      });
    } catch (error, stack) {
      _showMessage('Error updating score: $error', isError: true);
      print('DEBUG: Error updating score: $error');
      _logErrorToServer(error, stack, customMessage: 'Failed to update score');
    }
  }

  /// Performs the last undoable action from the `_undoStack`.
  Future<void> _performUndo() async {
    if (_undoStack.isEmpty) {
      _showMessage('No actions to undo.', isError: true);
      return;
    }
    // Ensure authentication is ready for undo operations
    if (!_isAuthReady || _userId == null) {
      _showMessage('Please wait for authentication to complete.', isError: true);
      return;
    }

    final lastAction = _undoStack.removeLast(); // Get and remove the last action

    try {
      CollectionReference targetCollection = _firestore
          .collection('artifacts')
          .doc(_appId)
          .collection('public')
          .doc('data')
          .collection('students');

      switch (lastAction.type) {
        case UndoableActionType.scoreUpdate:
          final String id = lastAction.data['id'];
          final int oldScore = lastAction.data['oldScore'];
          final String newEntryTimestampString = lastAction.data['newEntryTimestamp'];

          // Revert score to the score before this specific update
          await targetCollection.doc(id).update({'score': oldScore});

          // Fetch current history, remove the specific new entry by timestamp, and update Firestore
          final docRef = targetCollection.doc(id);
          final currentDoc = await docRef.get();
          if (currentDoc.exists) {
            List<ScoreHistoryEntry> currentHistory = ((currentDoc.data() as Map<String, dynamic>?)?['history'] as List<dynamic>?)
                ?.map((e) => ScoreHistoryEntry.fromMap(e as Map<String, dynamic>))
                .toList() ?? [];

            // Remove the entry that was just added based on its timestamp
            currentHistory.removeWhere((entry) => entry.timestamp.toIso8601String() == newEntryTimestampString);

            await docRef.update({'history': currentHistory.map((e) => e.toMap()).toList()});
          }

          _showMessage('Score update undone.');
          await _logActivity('Undo Score Update', {'id': id, 'revertedToScore': oldScore});
          break;

        case UndoableActionType.addEntity:
          final String id = lastAction.data['id'];
          await targetCollection.doc(id).delete(); // Delete the entity that was just added
          _showMessage('Added entity undone.');
          await _logActivity('Undo Add Entity', {'id': id});
          break;

        case UndoableActionType.deleteEntity:
          final String id = lastAction.data['id'];
          final Map<String, dynamic> originalData = lastAction.data['data'];
          await targetCollection.doc(id).set(originalData); // Re-add the entity that was just deleted
          _showMessage('Deleted entity undone.');
          await _logActivity('Undo Delete Entity', {'id': id});
          break;
      }
    } catch (error, stack) {
      _showMessage('Error performing undo: $error', isError: true);
      print('DEBUG: Error performing undo: $error');
      _logErrorToServer(error, stack, customMessage: 'Failed to perform undo');
      _undoStack.add(lastAction); // Push the action back if undo failed to ensure it's not lost
    }
  }

  /// Resets all scores for students/groups in the currently selected class to 100.
  void resetScores() async {
    // Ensure authentication is ready
    if (!_isAuthReady || _userId == null) {
      _showMessage('Please wait for authentication to complete.', isError: true);
      return;
    }
    final bool confirm = await showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Confirm Reset'),
        content: const Text('Are you sure you want to reset all scores to 100? This action cannot be undone.'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false), // Cancel
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(true), // Confirm
            child: const Text('Reset'),
          ),
        ],
      ),
    ) ?? false; // Default to false if dialog is dismissed

    if (confirm) {
      try {
        CollectionReference targetCollection = _firestore
            .collection('artifacts')
            .doc(_appId)
            .collection('public')
            .doc('data')
            .collection('students');

        final batch = _firestore.batch(); // Use a batch write for atomic updates
        // Filter students to reset only those in the currently selected class and not archived
        final studentsInClass = _allStudentGroups.where((group) => (_selectedClassId.isEmpty || group.classId == _selectedClassId) && !group.isArchived).toList();
        for (var group in studentsInClass) {
          final docRef = targetCollection.doc(group.id);
          // Update score to 100 and reset history to a single initial entry
          batch.update(docRef, {'score': 100, 'history': [ScoreHistoryEntry(score: 100, timestamp: DateTime.now()).toMap()]});
        }
        await batch.commit(); // Commit all batched writes
        print('All scores reset to 100 for class $_selectedClassId');
        await _logActivity('Reset Scores for Class', {'classId': _selectedClassId});
        _showMessage('All scores reset to 100.');
      } catch (error, stack) {
        _showMessage('Error resetting scores: $error', isError: true);
        print('DEBUG: Error resetting scores: $error');
        _logErrorToServer(error, stack, customMessage: 'Failed to reset scores');
      }
    }
  }

  /// Shows a dialog for selecting winners from the current class.
  /// Sorts by score descending to easily identify top performers.
  Future<List<StudentGroup>?> _showWinnersSelectionDialog() async {
    final studentsInClass = _allStudentGroups.where((group) =>
    (_selectWinnersSelectedClass.isEmpty || group.classId == _selectWinnersSelectedClass) && !group.isArchived).toList();

    studentsInClass.sort((a, b) => b.score.compareTo(a.score)); // Sort by score descending

    List<StudentGroup> selectedWinners = []; // List to hold temporarily selected winners

    final int maxScore = studentsInClass.isNotEmpty ? studentsInClass.first.score : 0;

    return await showDialog<List<StudentGroup>>(
      context: context,
      builder: (context) => StatefulBuilder( // Use StatefulBuilder for internal dialog state management
        builder: (context, setInnerState) {
          return AlertDialog(
            title: Text('Select Winner(s) for Class: ${_selectWinnersSelectedClass.isEmpty ? "All" : _selectWinnersSelectedClass}'),
            content: SizedBox(
              width: double.maxFinite, // Occupy maximum available width
              height: 300, // Fixed height to prevent overflow
              child: studentsInClass.isEmpty
                  ? const Center(child: Text('No students or groups in this class.'))
                  : ListView.builder(
                itemCount: studentsInClass.length,
                itemBuilder: (context, index) {
                  final item = studentsInClass[index];
                  final isSelected = selectedWinners.contains(item);

                  // Calculate growth and decrements for display in the selection dialog
                  final int initialScore = item.history.isNotEmpty ? item.history.first.score : item.score;
                  final int netGrowth = item.score - initialScore;
                  int totalDecrement = 0;
                  for (int i = 1; i < item.history.length; i++) {
                    final change = item.history[i].score - item.history[i-1].score;
                    if (change < 0) {
                      totalDecrement += change.abs();
                    }
                  }

                  final bool isTopScorer = item.score == maxScore && maxScore > 0;
                  final bool isHighGrowth = netGrowth > 0 && totalDecrement <= 10;
                  final bool isLowGrowth = netGrowth < 0 || totalDecrement > 10;

                  Color? tileColor;
                  if (isLowGrowth) {
                    tileColor = Colors.red.shade100;
                  } else if (isHighGrowth) {
                    tileColor = Colors.green.shade100;
                  }

                  return Container(
                    color: tileColor,
                    child: CheckboxListTile(
                      title: Row(
                        children: [
                          if (isTopScorer)
                            const Icon(Icons.star, color: Colors.amber, size: 20),
                          if (isHighGrowth)
                            const Icon(Icons.trending_up, color: Colors.green, size: 20),
                          if (isLowGrowth)
                            const Icon(Icons.trending_down, color: Colors.red, size: 20),
                          const SizedBox(width: 8),
                          Expanded(
                            child: Text(
                              '${item.name} (${item.isGroup ? "Group" : "Student"}) - Score: ${item.score}',
                              style: TextStyle(
                                color: isLowGrowth ? Colors.red.shade800 : Colors.black,
                                fontWeight: isTopScorer || isHighGrowth ? FontWeight.bold : FontWeight.normal,
                              ),
                            ),
                          ),
                        ],
                      ),
                      value: isSelected,
                      onChanged: (bool? value) {
                        setInnerState(() { // Update checkbox state
                          if (value == true) {
                            selectedWinners.add(item);
                          } else {
                            selectedWinners.remove(item);
                          }
                        });
                      },
                    ),
                  );
                },
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(null), // Cancel selection
                child: const Text('Cancel'),
              ),
              ElevatedButton(
                onPressed: () {
                  if (selectedWinners.isEmpty) {
                    _showMessage('Please select at least one winner.', isError: true);
                    return;
                  }
                  Navigator.of(context).pop(selectedWinners); // Return the list of selected winners
                },
                child: const Text('Declare Selected'),
              ),
            ],
          );
        },
      ),
    );
  }

  /// Declares selected students/groups as winners and records them in Firestore.
  void declareWinner() async {
    // Ensure authentication is ready
    if (!_isAuthReady || _userId == null) {
      _showMessage('Please wait for authentication to complete.', isError: true);
      return;
    }

    // First, allow the user to select the class for which winners will be declared
    final selectedClassForWinner = await showDialog<String>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Select Class for Winner'),
        content: DropdownButtonFormField<String>(
          value: _selectWinnersSelectedClass.isEmpty ? '' : (_uniqueClassIds.contains(_selectWinnersSelectedClass) ? _selectWinnersSelectedClass : null),
          items: [
            const DropdownMenuItem(value: '', child: Text('All Classes')),
            ..._uniqueClassIds.map((classId) {
              return DropdownMenuItem(value: classId, child: Text(classId));
            }).toList(),
          ],
          onChanged: (newValue) {
            if (newValue != null) {
              setState(() {
                _selectWinnersSelectedClass = newValue; // Update the class filter for winner selection
              });
            }
          },
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(null), // Cancel class selection
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop(_selectWinnersSelectedClass); // Select the class and proceed
            },
            child: const Text('Select'),
          ),
        ],
      ),
    );

    if (selectedClassForWinner == null) { // User cancelled class selection
      return;
    }

    // Then, show the dialog to select actual winners from the chosen class
    final List<StudentGroup>? selectedWinners = await _showWinnersSelectionDialog();

    if (selectedWinners == null || selectedWinners.isEmpty) {
      _showMessage('No winners selected.', isError: true);
      return;
    }

    final winnerNames = selectedWinners.map((w) => w.name).join(', ');
    final highestScore = selectedWinners.map((w) => w.score).reduce(math.max); // Get the highest score among declared winners

    // Confirm declaration with the user
    final bool confirm = await showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Confirm Declare Winner(s)'),
        content: Text('The selected winner(s): $winnerNames. Declare as winner?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false), // Cancel
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(true), // Confirm
            child: const Text('Declare'),
          ),
        ],
      ),
    ) ?? false;

    if (confirm) {
      try {
        final batch = _firestore.batch(); // Use a batch write for efficient multi-winner declaration
        for (var winner in selectedWinners) {
          final newWinner = Winner(
            studentGroupId: winner.id!,
            studentGroupName: winner.name,
            score: winner.score,
            timestamp: DateTime.now(),
            classId: winner.classId,
          );
          // Add winner to the public winners collection in Firestore
          batch.set(_firestore.collection('artifacts').doc(_appId).collection('public').doc('data').collection('winners').doc(), newWinner.toMap());
        }
        await batch.commit(); // Commit all batched writes
        print('Winner(s) declared: $winnerNames');
        await _logActivity('Declared Winner(s)', {'names': winnerNames, 'score': highestScore, 'classId': _selectWinnersSelectedClass});
        _showMessage('Winner(s) declared: $winnerNames');
      } catch (error, stack) {
        _showMessage('Error declaring winner: $error', isError: true);
        print('DEBUG: Error declaring winner: $error');
        _logErrorToServer(error, stack, customMessage: 'Failed to declare winner');
      }
    }
  }

  /// Logs an activity to the Firestore activity log.
  /// This provides an audit trail of actions within the application.
  Future<void> _logActivity(String action, [Map<String, dynamic>? details]) async {
    // Ensure authentication is ready before attempting to log activity
    if (!_isAuthReady || _userId == null) {
      print('DEBUG: Auth not ready. Cannot log activity to Firestore.');
      return;
    }

    try {
      await _firestore
          .collection('artifacts')
          .doc(_appId)
          .collection('public')
          .doc('data')
          .collection('activityLog')
          .add(AppActivity(
        id: uuid.v4(), // Generate a unique ID for the activity entry
        activityType: 'some_activity_type', // Replace with an appropriate string like 'error_log'
        description: 'some_description_for_activity', // Replace with a meaningful description
        classId: _selectedClassId,
        timestamp: DateTime.now(),
        details: details ?? {}, // Store any additional details
      ).toMap());
      print('DEBUG: Activity logged to Firestore: $action');
    } catch (error, stack) {
      print('DEBUG: Error logging activity to Firestore: $error');
      _showMessage('Error logging activity: $error', isError: true);
      _logErrorToServer(error, stack, customMessage: 'Failed to log activity');
    }
  }

  /// Uploads a class template from CSV data (web only feature).
  /// This feature requires a Node.js server endpoint to process the CSV and update Firestore.
  Future<void> _uploadClassTemplate() async {
    if (!kIsWeb) {
      _showMessage('This feature is only available in the web version.', isError: true);
      return;
    }
    // Ensure authentication is ready
    if (!_isAuthReady || _userId == null) {
      _showMessage('Please wait for authentication to complete.', isError: true);
      return;
    }

    final TextEditingController csvController = TextEditingController();
    final bool? confirm = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Upload Class Template (CSV)'),
        content: SizedBox(
          height: 250, // Fixed height for CSV input area
          child: TextField(
            controller: csvController,
            maxLines: null, // Allow unlimited lines for pasting CSV
            expands: true, // Expand to fill available height
            textAlignVertical: TextAlignVertical.top,
            decoration: const InputDecoration(
              hintText: 'Paste CSV data here (e.g., "name,isGroup (true/false),classId")',
              border: OutlineInputBorder(),
              alignLabelWithHint: true,
            ),
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false), // Cancel
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(true), // Upload
            child: const Text('Upload'),
          ),
        ],
      ),
    );

    if (confirm == true && csvController.text.isNotEmpty) {
      try {
        final response = await http.post(
          Uri.parse('$nodeServerBaseUrl/upload-class-template'), // Endpoint for CSV upload
          headers: {'Content-Type': 'text/csv'}, // Send as plain CSV text
          body: csvController.text,
        );

        if (response.statusCode == 200) {
          final Map<String, dynamic> jsonResponse = json.decode(response.body);
          if (jsonResponse['status'] == 'success') {
            _showMessage('Class template uploaded successfully!');
            await _logActivity('Uploaded Class Template', {'entriesCount': jsonResponse['newEntriesCount']});
          } else {
            _showMessage('Upload failed: ${jsonResponse['message']}', isError: true);
          }
        } else {
          _showMessage('Server error during upload: ${response.statusCode}', isError: true);
        }
      } catch (error, stack) {
        _showMessage('Error uploading template: $error', isError: true);
        debugPrint('DEBUG: Error uploading template: $error');
        _logErrorToServer(error, stack, customMessage: 'Failed to upload class template');
      }
    } else if (confirm == true && csvController.text.isEmpty) {
      _showMessage('CSV data cannot be empty.', isError: true);
    }
  }

  /// Performs a backup of the Firestore data to the Node.js server (web only feature).
  /// This operation is handled server-side.
  Future<void> _performBackup() async {
    if (!kIsWeb) {
      _showMessage('This feature is only available in the web version.', isError: true);
      return;
    }
    // Ensure authentication is ready
    if (!_isAuthReady || _userId == null) {
      _showMessage('Please wait for authentication to complete.', isError: true);
      return;
    }
    try {
      final response = await http.post(Uri.parse('$nodeServerBaseUrl/backup')); // Trigger server backup
      if (response.statusCode == 200) {
        _showMessage('Backup created successfully!');
        await _logActivity('Performed Backup');
      } else {
        _showMessage('Backup failed: ${response.body}', isError: true);
      }
    } catch (error, stack) {
      _showMessage('Error performing backup: $error', isError: true);
      debugPrint('DEBUG: Error performing backup: $error');
      _logErrorToServer(error, stack, customMessage: 'Failed to perform backup');
    }
  }

  /// Restores Firestore data from a selected backup on the Node.js server (web only feature).
  /// This operation is handled server-side and will overwrite existing data.
  Future<void> _restoreBackup() async {
    if (!kIsWeb) {
      _showMessage('This feature is only available in the web version.', isError: true);
      return;
    }
    // Ensure authentication is ready
    if (!_isAuthReady || _userId == null) {
      _showMessage('Please wait for authentication to complete.', isError: true);
      return;
    }
    try {
      // Fetch available backups from the server
      final response = await http.get(Uri.parse('$nodeServerBaseUrl/backups'));
      if (response.statusCode == 200) {
        final List<Map<String, dynamic>> backups = (json.decode(response.body) as Map<String, dynamic>)['backups']?.cast<Map<String, dynamic>>().toList() ?? [];
        if (backups.isEmpty) {
          _showMessage('No backups available on the server.', isError: true);
          return;
        }

        // Show dialog to allow user to select a backup file
        final selectedBackupFilename = await showDialog<String>(
          context: context,
          builder: (context) => AlertDialog(
            title: const Text('Select Backup to Restore'),
            content: SizedBox(
              width: double.maxFinite,
              height: 300,
              child: ListView.builder(
                shrinkWrap: true, // Allow ListView to take minimum required height
                itemCount: backups.length,
                itemBuilder: (context, index) {
                  final backup = backups[index];
                  return ListTile(
                    title: Text(backup['filename']),
                    subtitle: Text(DateFormat('yyyy-MM-dd HH:mm').format(DateTime.parse(backup['timestamp']))),
                    onTap: () => Navigator.of(context).pop(backup['filename']), // Return selected filename
                  );
                },
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(), // Cancel
                child: const Text('Cancel'),
              ),
            ],
          ),
        );

        if (selectedBackupFilename != null) {
          // Confirm restoration as it overwrites data, a strong warning is needed
          final confirmRestore = await showDialog<bool>(
            context: context,
            builder: (context) => AlertDialog(
              title: const Text('Confirm Restore'),
              content: Text('Are you sure you want to restore from "$selectedBackupFilename"? This will overwrite ALL current student/group data and cannot be undone.'),
              actions: [
                TextButton(
                  onPressed: () => Navigator.of(context).pop(false), // Cancel
                  child: const Text('Cancel'),
                ),
                ElevatedButton(
                  onPressed: () => Navigator.of(context).pop(true), // Confirm
                  child: const Text('Restore'),
                ),
              ],
            ),
          ) ?? false;

          if (confirmRestore) {
            final restoreResponse = await http.post(Uri.parse('$nodeServerBaseUrl/restore-specific/$selectedBackupFilename')); // Trigger server restore
            if (restoreResponse.statusCode == 200) {
              _showMessage('Data restored successfully from $selectedBackupFilename!');
              await _logActivity('Restored Backup', {'filename': selectedBackupFilename});
              // Data will automatically refresh via Firestore listeners
            } else {
              _showMessage('Restore failed: ${restoreResponse.body}', isError: true);
            }
          }
        }
      } else {
        _showMessage('Failed to fetch backup list: ${response.body}', isError: true);
      }
    } catch (error, stack) {
      _showMessage('Error restoring backup: $error', isError: true);
      debugPrint('DEBUG: Error restoring backup: $error');
      _logErrorToServer(error, stack, customMessage: 'Failed to restore backup');
    }
  }

  /// Triggers an automatic backup on app close (web only).
  /// This function is called via `didChangeAppLifecycleState`.
  void _triggerAutomaticBackupOnClose() async {
    if (!kIsWeb) return; // Only for web
    try {
      await http.post(Uri.parse('$nodeServerBaseUrl/backup'));
      print('DEBUG: Automatic backup triggered successfully on app close (web).');
    } catch (error, stack) {
      print('DEBUG: Error triggering automatic backup (web): $error');
      _logErrorToServer(error, stack, customMessage: 'Automatic backup trigger failed');
    }
  }

  /// Sorts a list of StudentGroup objects based on the current sorting criteria.
  List<StudentGroup> _sortItems(List<StudentGroup> items) {
    items.sort((a, b) {
      int compareResult;
      switch (_currentSortCriteria) {
        case 'name':
          compareResult = a.name.compareTo(b.name);
          break;
        case 'score':
          compareResult = a.score.compareTo(b.score);
          break;
        case 'historyCount':
          compareResult = a.history.length.compareTo(b.history.length);
          break;
        case 'growth':
          final growthA = a.history.isNotEmpty ? (a.history.last.score - a.history.first.score) : 0;
          final growthB = b.history.isNotEmpty ? (b.history.last.score - b.history.first.score) : 0;
          compareResult = growthA.compareTo(growthB);
          break;
        default:
          compareResult = 0; // No specific sort, maintain original order
      }
      return _sortAscending ? compareResult : -compareResult; // Apply ascending/descending order
    });
    return items;
  }

  /// Sorts a list of Winner objects based on timestamp or growth.
  List<Winner> _sortWinners(List<Winner> winners) {
    if (_sortByGrowthInWinners) {
      return winners.sorted((a, b) {
        // Find corresponding student groups to calculate growth dynamically
        final studentA = _allStudentGroups.firstWhereOrNull((s) => s.id == a.studentGroupId);
        final studentB = _allStudentGroups.firstWhereOrNull((s) => s.id == b.studentGroupId);

        if (studentA == null || studentA.history.isEmpty) return 1; // Put students with no history at the end
        if (studentB == null || studentB.history.isEmpty) return -1;

        final growthA = studentA.history.last.score - studentA.history.first.score;
        final growthB = studentB.history.last.score - studentB.history.first.score;

        return growthB.compareTo(growthA); // Sort by growth (descending: highest growth first)
      });
    } else {
      return winners.sorted((a, b) => b.timestamp.compareTo(a.timestamp)); // Default sort by timestamp (latest first)
    }
  }

  /// Allows uploading a photo for a declared winner using ImagePicker and Firebase Storage.
  Future<void> _uploadWinnerPhoto(Winner winner) async {
    // Ensure authentication is ready
    if (!_isAuthReady || _userId == null) {
      _showMessage('Please wait for authentication to complete.', isError: true);
      return;
    }

    try {
      final XFile? image = await _picker.pickImage(source: ImageSource.gallery); // Pick image from device gallery

      if (image != null) {
        _showMessage('Uploading image...');
        final String fileName = '${winner.id}_${DateTime.now().millisecondsSinceEpoch}.jpg'; // Unique file name
        // Create a Firebase Storage reference pointing to a specific path for winner photos
        final Reference ref = _storage.ref().child('winners_photos').child(winner.id!).child(fileName);

        UploadTask uploadTask;
        if (kIsWeb) {
          uploadTask = ref.putData(await image.readAsBytes()); // For web, upload byte data directly
        } else {
          uploadTask = ref.putFile(io.File(image.path)); // For mobile, upload file from path
        }

        final TaskSnapshot snapshot = await uploadTask;
        final String downloadUrl = await snapshot.ref.getDownloadURL(); // Get public download URL of the uploaded image

        // Update the winner document in Firestore with the new image URL
        await _firestore
            .collection('artifacts')
            .doc(_appId)
            .collection('public')
            .doc('data')
            .collection('winners')
            .doc(winner.id)
            .update({'imageUrl': downloadUrl});

        _showMessage('Image uploaded successfully!');
        await _logActivity('Uploaded Winner Photo', {'winnerId': winner.id, 'winnerName': winner.studentGroupName, 'imageUrl': downloadUrl});
      } else {
        _showMessage('No image selected.', isError: true);
      }
    } catch (e, stack) {
      _showMessage('Error uploading image: $e', isError: true);
      print('DEBUG: Error uploading image: $e');
      _logErrorToServer(e, stack, customMessage: 'Failed to upload winner photo');
    }
  }

  /// Takes a screenshot of the main student/group list area.
  /// The screenshot can then be downloaded on web or shared on mobile.
  Future<void> _takeScreenshot() async {
    if (_listKey.currentContext == null) {
      _showMessage('Cannot take screenshot: list not rendered.', isError: true);
      return;
    }

    _showMessage('Taking screenshot...', isError: false);
    // Find the RenderRepaintBoundary associated with the _listKey for screenshot capture
    RenderRepaintBoundary? boundary = _listKey.currentContext!.findRenderObject() as RenderRepaintBoundary?;

    if (boundary == null) {
      _showMessage('Error: Could not find render boundary for screenshot.', isError: true);
      return;
    }

    try {
      // Convert the boundary to an image with a higher pixel ratio for better quality
      ui.Image image = await boundary.toImage(pixelRatio: 3.0);
      ByteData? byteData = await image.toByteData(format: ui.ImageByteFormat.png);
      if (byteData == null) {
        _showMessage('Error: Could not convert image to bytes.', isError: true);
        return;
      }

      Uint8List pngBytes = byteData.buffer.asUint8List();

      if (kIsWeb) {
        // For web, create a downloadable link element and trigger a click
        html.AnchorElement(href: 'data:image/png;base64,${base64Encode(pngBytes)}')
          ..setAttribute('download', 'score_tracker_list_${DateFormat('yyyyMMdd_HHmmss').format(DateTime.now())}.png')
          ..click();
        _showMessage('Screenshot downloaded!', isError: false);
      } else {
        // For mobile, save to a temporary directory and then use share_plus to share the file
        final directory = await getTemporaryDirectory();
        final filePath = '${directory.path}/score_tracker_list_${DateFormat('yyyyMMdd_HHmmss').format(DateTime.now())}.png';
        final file = io.File(filePath);
        await file.writeAsBytes(pngBytes);

        await Share.shareXFiles([XFile(filePath)], text: 'Score Tracker List');
        _showMessage('Screenshot shared!', isError: false);
      }
    } catch (e, stack) {
      _showMessage('Failed to take screenshot: $e', isError: true);
      print('DEBUG: Screenshot error: $e');
      _logErrorToServer(e, stack, customMessage: 'Failed to take screenshot');
    }
  }

  /// Shows a dialog for manual class ID input to filter the main data list.
  /// This replaces the "Guest Mode" class ID input.
  void _showGuestModeClassIdDialog() async {
    // This dialog is now effectively just a class filter for the public data
    _guestClassIdController.text = _selectedClassId; // Pre-fill with current filter
    final bool? confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Filter by Class'),
        content: TextField(
          controller: _guestClassIdController,
          decoration: const InputDecoration(
            labelText: 'Class ID (e.g., 8A, 7B)',
            hintText: 'Leave empty for all classes',
          ),
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.of(context).pop(false); // Cancel
            },
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop(true); // Apply filter
            },
            child: const Text('Apply Filter'),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      final String filterClassId = _guestClassIdController.text.trim();
      setState(() {
        _selectedClassId = filterClassId; // Update the class filter state
      });
      _subscribeToFirestoreData(); // Re-subscribe to Firestore with the new filter
      _showMessage('Filtering by class: ${filterClassId.isEmpty ? "All" : filterClassId}.');
    }
  }

  /// Shows a dialog to update a student/group's score with a reason and optional comment.
  /// Default reasons are provided based on positive or negative score changes.
  void _showScoreUpdateDialog(StudentGroup item) async {
    final TextEditingController scoreChangeController = TextEditingController();
    String? selectedReason;
    final TextEditingController customCommentController = TextEditingController();
    final _formKey = GlobalKey<FormState>(); // Key for form validation

    await showDialog(
      context: context,
      builder: (context) => StatefulBuilder( // Use StatefulBuilder to update dialog UI based on input
        builder: (context, setInnerState) {
          return AlertDialog(
            title: Text('Update Score for ${item.name}'),
            content: Form(
              key: _formKey,
              child: SingleChildScrollView(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text('Current Score: ${item.score}', style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
                    const SizedBox(height: 16),
                    // Score change input field
                    TextFormField(
                      controller: scoreChangeController,
                      keyboardType: TextInputType.number,
                      decoration: const InputDecoration(
                        labelText: 'Score Change (+/-)',
                        hintText: 'e.g., 10 or -5',
                        border: OutlineInputBorder(),
                      ),
                      validator: (value) {
                        if (value == null || value.trim().isEmpty) {
                          return 'Score change is mandatory';
                        }
                        if (int.tryParse(value.trim()) == null) {
                          return 'Please enter a valid number';
                        }
                        return null;
                      },
                      onChanged: (value) { // Dynamically set default reason based on score change
                        if (int.tryParse(value.trim()) != null) {
                          final int change = int.parse(value.trim());
                          setInnerState(() { // Update dialog's internal state
                            if (change > 0) {
                              selectedReason = "Activity Performance";
                            } else if (change < 0) {
                              selectedReason = "Violating norms";
                            } else {
                              selectedReason = null; // No default if change is zero
                            }
                            if (selectedReason != 'Custom') {
                              customCommentController.clear(); // Clear custom comment if reason changes from 'Custom'
                            }
                          });
                        } else {
                          setInnerState(() {
                            selectedReason = null; // Clear reason if input is invalid
                            customCommentController.clear();
                          });
                        }
                      },
                    ),
                    const SizedBox(height: 16),
                    // Reason dropdown
                    DropdownButtonFormField<String>(
                      decoration: const InputDecoration(
                        labelText: 'Reason (Mandatory)',
                        border: OutlineInputBorder(),
                      ),
                      value: selectedReason, // Current selected reason (could be default or user-chosen)
                      hint: const Text('Select a reason'),
                      items: _scoreReasons.map((reason) {
                        return DropdownMenuItem(
                          value: reason,
                          child: Text(reason),
                        );
                      }).toList(),
                      onChanged: (newValue) {
                        setInnerState(() { // Update dialog state
                          selectedReason = newValue;
                          if (newValue != 'Custom') {
                            customCommentController.clear(); // Clear custom comment if reason is not 'Custom'
                          }
                        });
                      },
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Reason is mandatory';
                        }
                        return null;
                      },
                    ),
                    // Custom comment field (only visible if reason is 'Custom')
                    if (selectedReason == 'Custom') ...[
                      const SizedBox(height: 16),
                      TextFormField(
                        controller: customCommentController,
                        maxLines: 3,
                        decoration: const InputDecoration(
                          labelText: 'Custom Comment (Mandatory for Custom Reason)',
                          hintText: 'Add any additional notes',
                          border: OutlineInputBorder(),
                        ),
                        validator: (value) {
                          if (selectedReason == 'Custom' && (value == null || value.trim().isEmpty)) {
                            return 'Custom comment is mandatory for "Custom" reason';
                          }
                          return null;
                        },
                      ),
                    ],
                  ],
                ),
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context), // Cancel
                child: const Text('Cancel'),
              ),
              ElevatedButton(
                onPressed: () {
                  if (_formKey.currentState!.validate()) { // Validate all form fields
                    final int change = int.parse(scoreChangeController.text.trim());
                    Navigator.pop(context); // Close dialog
                    updateScore(item.id!, item.score, change, item.name, selectedReason!, customCommentController.text.trim());
                  }
                },
                child: const Text('Update'),
              ),
            ],
          );
        },
      ),
    );
  }

  /// Shows a leaderboard based on selected score reasons.
  /// Displays net score changes for a specific reason and sorts accordingly.
  void _showReasonBasedLeaderboardDialog() async {
    await showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setInnerState) {
          Map<String, int> reasonScores = {}; // Map to store total scores per reason for each student/group

          if (_selectedReasonForLeaderboard != null) {
            // Calculate total score changes for the selected reason for each student/group
            for (var studentGroup in _allStudentGroups) {
              int totalScoreForReason = 0;
              // Iterate through history to calculate score changes for the selected reason
              // Start from 1 to compare with previous entry
              for (int i = 1; i < studentGroup.history.length; i++) {
                final entry = studentGroup.history[i];
                if (entry.reason == _selectedReasonForLeaderboard) {
                  int previousScore = studentGroup.history[i-1].score;
                  totalScoreForReason += (entry.score - previousScore);
                }
              }
              // Handle initial score if its reason matches (only if it's explicitly recorded with a reason)
              // This assumes an initial score of 100 for newly added students.
              if (studentGroup.history.isNotEmpty && studentGroup.history.first.reason == _selectedReasonForLeaderboard) {
                totalScoreForReason += (studentGroup.history.first.score - 100);
              }

              if (totalScoreForReason != 0) { // Only add if there's a net score change for this reason
                reasonScores[studentGroup.id!] = totalScoreForReason;
              }
            }
          }

          List<Map<String, dynamic>> leaderboardEntries = [];
          reasonScores.forEach((id, score) {
            final studentGroup = _allStudentGroups.firstWhereOrNull((s) => s.id == id);
            if (studentGroup != null) {
              leaderboardEntries.add({
                'name': studentGroup.name,
                'score': score, // This is the net change for the reason
                'isGroup': studentGroup.isGroup,
              });
            }
          });

          // Custom sorting for reason-based leaderboard:
          // Negative reasons (Violating norms, Unhealthy behaviour) are sorted ascending (most negative first)
          // Other reasons are sorted descending (highest positive change first)
          leaderboardEntries.sort((a, b) {
            final scoreA = a['score'] as int;
            final scoreB = b['score'] as int;

            const negativeReasons = ["Violating norms", "Unhealthy behaviour"];

            if (_selectedReasonForLeaderboard != null && negativeReasons.contains(_selectedReasonForLeaderboard)) {
              return scoreA.compareTo(scoreB); // Ascending order for negative impact
            } else {
              return scoreB.compareTo(scoreA); // Default descending order for positive impact
            }
          });

          return AlertDialog(
            title: const Text('Reason-Based Leaderboard'),
            content: SizedBox(
              width: double.maxFinite,
              child: Column(
                mainAxisSize: MainAxisSize.min, // Column takes minimum space
                children: [
                  Flexible( // Make dropdown flexible to adapt to screen size
                    child: DropdownButtonFormField<String>(
                      decoration: const InputDecoration(
                        labelText: 'Select Reason',
                        border: OutlineInputBorder(),
                        contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                      ),
                      value: _selectedReasonForLeaderboard,
                      hint: const Text('Choose a reason'),
                      items: _scoreReasons.map((reason) {
                        return DropdownMenuItem(value: reason, child: Text(reason));
                      }).toList(),
                      onChanged: (newValue) {
                        setInnerState(() { // Update dialog's internal state
                          _selectedReasonForLeaderboard = newValue;
                        });
                      },
                    ),
                  ),
                  const SizedBox(height: 16),
                  // Conditional display based on selection and data availability
                  if (_selectedReasonForLeaderboard == null)
                    const Expanded(
                      child: Center(child: Text('Please select a reason to view the leaderboard.')),
                    )
                  else if (leaderboardEntries.isEmpty)
                    Expanded(
                      child: Center(child: Text('No data for "${_selectedReasonForLeaderboard}" yet.')),
                    )
                  else // Display the leaderboard entries
                    Expanded( // List takes remaining space
                      child: ListView.builder(
                        shrinkWrap: true, // Allow ListView to take only needed space
                        itemCount: leaderboardEntries.length,
                        itemBuilder: (context, index) {
                          final entry = leaderboardEntries[index];
                          // Determine color based on net score change for the reason
                          Color scoreColor = Colors.black;
                          if (entry['score'] > 0) {
                            scoreColor = Colors.green;
                          } else if (entry['score'] < 0) {
                            scoreColor = Colors.red;
                          }

                          return ListTile(
                            leading: Text('#${index + 1}', style: TextStyle(color: scoreColor)),
                            title: Text('${entry['name']} (${entry['isGroup'] ? "Group" : "Student"})', style: TextStyle(color: scoreColor)),
                            trailing: Text('Net Change: ${entry['score']}', style: TextStyle(color: scoreColor)),
                          );
                        },
                      ),
                    ),
                ],
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(), // Close button
                child: const Text('Close'),
              ),
            ],
          );
        },
      ),
    );
  }

  /// Shows a dialog to manage hidden (archived) students/groups.
  /// Users can view all students/groups for a selected class and toggle their archived status.
  void _showManageHiddenStudentsDialog() async {
    // Ensure authentication is ready
    if (!_isAuthReady || _userId == null) {
      _showMessage('Please wait for authentication to complete.', isError: true);
      return;
    }

    // First, allow the user to select a class to filter the management list
    String? selectedClassForHiddenManagement = await showDialog<String>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Select Class to Manage Hidden Students'),
        content: DropdownButtonFormField<String>(
          value: _selectedClassId.isEmpty ? '' : (_uniqueClassIds.contains(_selectedClassId) ? _selectedClassId : null),
          items: [
            const DropdownMenuItem(value: '', child: Text('All Classes')),
            ..._uniqueClassIds.map((classId) {
              return DropdownMenuItem(value: classId, child: Text(classId));
            }).toList(),
          ],
          onChanged: (newValue) {
            if (newValue != null) {
              // Note: this setState updates the dialog's _selectedClassId and rebuilds the dialog content,
              // but doesn't affect the HomePage's `_selectedClassId` until the dialog is confirmed.
              setState(() {
                _selectedClassId = newValue; // Temporarily update for this dialog's context
              });
            }
          },
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(null), // Cancel selection
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              // Return the currently selected class ID from the dropdown
              final selectedValue = (_uniqueClassIds.contains(_selectedClassId) ? _selectedClassId : '') ;
              Navigator.of(context).pop(selectedValue);
            },
            child: const Text('Select'),
          ),
        ],
      ),
    );

    if (selectedClassForHiddenManagement == null) {
      _showMessage('Hidden student management cancelled.', isError: false);
      return;
    }

    // Fetch ALL students/groups for the selected class, *regardless* of their current archive status.
    List<StudentGroup> studentsToManage = [];
    try {
      // Explicitly type the CollectionReference to ensure QuerySnapshot is also correctly typed.
      CollectionReference<Map<String, dynamic>> studentsRef = _firestore
          .collection('artifacts')
          .doc(_appId)
          .collection('public')
          .doc('data')
          .collection('students');

      late QuerySnapshot<Map<String, dynamic>> snapshot; // Changed to late to allow conditional assignment
      if (selectedClassForHiddenManagement.isNotEmpty) {
        // Query for students in the specific class
        snapshot = await studentsRef.where('classId', isEqualTo: selectedClassForHiddenManagement).get();
      } else {
        // Query for all students across all classes
        snapshot = await studentsRef.get();
      }

      studentsToManage = snapshot.docs.map((doc) => StudentGroup.fromMap(doc.data(), id: doc.id)).toList();
    } catch (e, stack) {
      _showMessage('Error fetching students for management: $e', isError: true);
      _logErrorToServer(e, stack, customMessage: 'Failed to fetch students for archive management');
      return;
    }

    // Create a temporary map to store the new archive status for each item during the dialog
    Map<String, bool> tempArchiveStatus = {};
    for (var item in studentsToManage) {
      tempArchiveStatus[item.id!] = item.isArchived; // Initialize with current status
    }

    await showDialog(
      context: context,
      builder: (context) => StatefulBuilder( // Use StatefulBuilder for the inner dialog content
        builder: (context, setInnerState) {
          return AlertDialog(
            title: Text('Manage Hidden Students/Groups (Class: ${selectedClassForHiddenManagement.isEmpty ? "All" : selectedClassForHiddenManagement})'),
            content: SizedBox(
              width: double.maxFinite,
              height: 400,
              child: studentsToManage.isEmpty
                  ? const Center(child: Text('No students or groups in this class.'))
                  : ListView.builder(
                itemCount: studentsToManage.length,
                itemBuilder: (context, index) {
                  final item = studentsToManage[index];
                  final bool isCurrentlyArchived = tempArchiveStatus[item.id!] ?? item.isArchived;

                  return CheckboxListTile(
                    title: Text('${item.name} (${item.isGroup ? "Group" : "Student"})'),
                    value: isCurrentlyArchived,
                    onChanged: (bool? value) {
                      setInnerState(() { // Update the temporary status for the checkbox
                        tempArchiveStatus[item.id!] = value ?? false;
                      });
                    },
                  );
                },
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(), // Cancel
                child: const Text('Cancel'),
              ),
              ElevatedButton(
                onPressed: () async {
                  Navigator.of(context).pop(); // Close dialog immediately

                  final batch = _firestore.batch(); // Use a batch for multiple updates
                  int updatedCount = 0;

                  for (var item in studentsToManage) { // Iterate through the initially fetched list
                    final bool newStatus = tempArchiveStatus[item.id!] ?? item.isArchived;
                    if (newStatus != item.isArchived) { // Only update if status has changed
                      batch.update(_firestore.collection('artifacts').doc(_appId).collection('public').doc('data').collection('students').doc(item.id), {
                        'isArchived': newStatus,
                      });
                      updatedCount++;
                    }
                  }

                  if (updatedCount > 0) {
                    try {
                      await batch.commit(); // Commit all changes to Firestore
                      _showMessage('$updatedCount students/groups archive status updated.');
                      await _logActivity('Bulk Archive Status Update', {'classId': selectedClassForHiddenManagement, 'updatedCount': updatedCount});
                      _subscribeToFirestoreData(); // Re-subscribe to update the main list view
                    } catch (e, stack) {
                      _showMessage('Error updating archive status: $e', isError: true);
                      _logErrorToServer(e, stack, customMessage: 'Bulk archive update failed');
                    }
                  } else {
                    _showMessage('No changes to archive status were made.');
                  }
                },
                child: const Text('Apply Changes'),
              ),
            ],
          );
        },
      ),
    );
  }

  /// Generates and allows sharing a link to a visual report.
  /// The link points to the `ReportViewerPage` with a unique report ID.
  Future<void> _generateAndShareReport() async {
    // Ensure authentication is ready
    if (!_isAuthReady || _userId == null) {
      _showMessage('Please wait for authentication to complete.', isError: true);
      return;
    }

    // First, allow the user to select the class for which the report will be generated
    String? selectedClassForReport = await showDialog<String>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Select Class for Report'),
        content: DropdownButtonFormField<String>(
          value: _selectedClassId.isEmpty ? '' : (_uniqueClassIds.contains(_selectedClassId) ? _selectedClassId : null),
          items: [
            const DropdownMenuItem(value: '', child: Text('All Classes')),
            ..._uniqueClassIds.map((classId) {
              return DropdownMenuItem(value: classId, child: Text(classId));
            }).toList(),
          ],
          onChanged: (newValue) {
            if (newValue != null) {
              setState(() {
                _selectedClassId = newValue; // Temporarily update for this dialog context
              });
            }
          },
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(null), // Cancel
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop(_selectedClassId); // Select the class and proceed
            },
            child: const Text('Generate Report Link'),
          ),
        ],
      ),
    );

    if (selectedClassForReport == null) {
      _showMessage('Report link generation cancelled.', isError: false);
      return;
    }

    _showMessage('Generating report link...', isError: false);

    try {
      final String reportId = uuid.v4(); // Generate a unique ID for the report link
      final SharedReport newSharedReport = SharedReport(
        id: reportId,
        classId: selectedClassForReport,
        generatedAt: DateTime.now(),
        generatorUserId: _userId,
        active: true, // Initially active
      );

      // Save the shared report metadata to the public collection in Firestore
      await _firestore
          .collection('artifacts')
          .doc(_appId) // Use the global appId for public data
          .collection('public')
          .doc('data')
          .collection('sharedReports')
          .doc(reportId)
          .set(newSharedReport.toMap());

      // Construct the shareable URL
      String shareableLink;
      if (kIsWeb) {
        // For web, use the current origin and append the reportId as a query parameter
        shareableLink = '${html.window.location.href.split('?')[0].split('#')[0]}?reportId=$reportId';
      } else {
        // For mobile, construct a generic link to the web report viewer.
        // For actual deep linking to the native app, a separate deep link setup (e.g., Firebase Dynamic Links) would be needed.
        shareableLink = 'https://scoretracker4321.github.io/score-tracker-web/?reportId=$reportId'; // IMPORTANT: Replace with your actual deployed web URL
      }

      _showMessage('Report link generated!');
      await _logActivity('Generated Shareable Report Link', {'classId': selectedClassForReport, 'reportId': reportId});

      // Show dialog with the link and options to copy or share
      await showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('Share Report Link'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text('Share this link to allow others to view the report:'),
              const SizedBox(height: 8),
              SelectableText(shareableLink, style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.blue)),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () {
                PlatformClipboard.instance.copyText(shareableLink); // Use platform clipboard for copy
                _showMessage('Link copied to clipboard!');
                Navigator.of(context).pop();
              },
              child: const Text('Copy Link'),
            ),
            if (!kIsWeb) // Share button only for mobile platforms (uses share_plus)
              ElevatedButton(
                onPressed: () {
                  Share.share(shareableLink, subject: 'Score Tracker Report');
                  Navigator.of(context).pop();
                },
                child: const Text('Share'),
              ),
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('Close'),
            ),
          ],
        ),
      );
    } catch (e, stack) {
      _showMessage('Error generating report link: $e', isError: true);
      print('DEBUG: Report link generation error: $e');
      _logErrorToServer(e, stack, customMessage: 'Failed to generate shareable report link');
    }
  }

  @override
  Widget build(BuildContext context) {
    // Filter and sort the student groups based on current criteria
    List<StudentGroup> filteredGroups = _allStudentGroups.where((group) {
      bool matchesClass = _selectedClassId.isEmpty || group.classId == _selectedClassId;
      bool matchesType = true;
      bool matchesAlphabet = true;
      // This filter is for the main display, only show non-archived unless _showArchivedStudents is true
      bool matchesArchiveStatus = !group.isArchived;

      if (_entityTypeFilter == 'Students Only') {
        matchesType = !group.isGroup;
      } else if (_entityTypeFilter == 'Groups Only') {
        matchesType = group.isGroup;
      }

      if (_selectedAlphabetFilter.isNotEmpty) {
        matchesAlphabet = group.name.toLowerCase().startsWith(_selectedAlphabetFilter.toLowerCase());
      }

      return matchesClass && matchesType && matchesAlphabet && matchesArchiveStatus;
    }).toList();

    _sortItems(filteredGroups); // Apply sorting to the filtered list

    // Update counts of filtered students and groups for display
    _filteredStudentsCount = filteredGroups.where((item) => !item.isGroup).length;
    _filteredGroupsCount = filteredGroups.where((item) => item.isGroup).length;

    // Determine the current value for the class filter dropdown, handling 'All Classes' and invalid selections
    String? currentDropdownValue;
    if (_selectedClassId.isEmpty) {
      currentDropdownValue = ''; // Represents "All Classes"
    } else if (_uniqueClassIds.contains(_selectedClassId)) {
      currentDropdownValue = _selectedClassId;
    } else {
      currentDropdownValue = null; // If selected class is no longer in unique IDs, or initially invalid
    }

    // Generate alphabet list for filtering A-Z
    final List<String> alphabet = List.generate(26, (index) => String.fromCharCode('A'.codeUnitAt(0) + index));

    return Scaffold(
      appBar: AppBar(
        title: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Score Tracker (Public Access)',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
              overflow: TextOverflow.ellipsis,
            ),
            Text(
              'App ID: $_appId', // Display the App ID for debugging/info
              style: const TextStyle(fontSize: 10, color: Colors.white70),
              overflow: TextOverflow.ellipsis,
            ),
            Text(
              'User ID: ${_userId ?? "N/A"}', // Display the User ID for debugging/info
              style: const TextStyle(fontSize: 10, color: Colors.white70),
              overflow: TextOverflow.ellipsis,
            ),
          ],
        ),
        centerTitle: false, // Align title to start
        actions: [
          // Undo button, visible only if there are actions to undo
          if (_undoStack.isNotEmpty)
            IconButton(
              icon: const Icon(Icons.undo),
              onPressed: _performUndo,
              tooltip: 'Undo Last Action',
            ),
          // Add new student/group button
          IconButton(
            icon: const Icon(Icons.add),
            onPressed: _showAddEntityDialog,
            tooltip: 'Add New Student or Group',
          ),
          // Toggle between list view and growth leaderboard view
          IconButton(
            icon: Icon(_showGrowthLeaderboard ? Icons.list : Icons.bar_chart),
            onPressed: () {
              setState(() {
                _showGrowthLeaderboard = !_showGrowthLeaderboard;
              });
            },
            tooltip: _showGrowthLeaderboard ? 'Show Student/Group List' : 'Show Growth Leaderboard',
          ),
          // Screenshot button
          IconButton(
            icon: const Icon(Icons.screenshot),
            onPressed: _takeScreenshot,
            tooltip: 'Take Screenshot of List',
          ),
        ],
      ),
      drawer: Drawer(
        child: ListView(
          padding: EdgeInsets.zero,
          children: <Widget>[
            const DrawerHeader(
              decoration: BoxDecoration(
                color: Colors.lightBlue,
              ),
              child: Text('Score Tracker Options', style: TextStyle(color: Colors.white, fontSize: 20)),
            ),
            ListTile(
              title: const Text('Add New Student/Group'),
              onTap: () {
                Navigator.pop(context); // Close drawer
                _showAddEntityDialog();
              },
            ),
            ListTile(
              title: const Text('Reset All Scores for Current Class'),
              onTap: () {
                Navigator.pop(context); // Close drawer
                resetScores();
              },
            ),
            ListTile(
              title: const Text('Declare Winner(s)'),
              onTap: () {
                Navigator.pop(context); // Close drawer
                declareWinner();
              },
            ),
            ListTile(
              title: const Text('Reason-Based Leaderboard'),
              onTap: () {
                Navigator.pop(context); // Close drawer
                _showReasonBasedLeaderboardDialog();
              },
            ),
            ListTile(
              title: const Text('Manage Hidden Students'), // Renamed from 'Show Archived Students'
              onTap: () {
                Navigator.pop(context); // Close drawer
                _showManageHiddenStudentsDialog(); // Open the new dialog
              },
            ),
            // Web-specific features, visible only on web
            if (kIsWeb) ...[
              const Divider(),
              ListTile(
                title: const Text('Upload Class Template (CSV)'),
                onTap: () {
                  Navigator.pop(context);
                  _uploadClassTemplate();
                },
              ),
              ListTile(
                title: const Text('Backup Data (Server)'),
                onTap: () {
                  Navigator.pop(context);
                  _performBackup();
                },
              ),
              ListTile(
                title: const Text('Restore Data (Server)'),
                onTap: () {
                  Navigator.pop(context);
                  _restoreBackup();
                },
              ),
              // Removed 'Generate Guest View Link' as requested
            ],
            // Activity Log
            const Divider(),
            ListTile(
              title: const Text('View Activity Log'),
              onTap: () {
                Navigator.pop(context); // Close drawer
                showDialog(
                  context: context,
                  builder: (context) => AlertDialog(
                    title: const Text('Activity Log'),
                    content: SizedBox(
                      width: double.maxFinite,
                      height: 300,
                      child: ListView.builder(
                        shrinkWrap: true,
                        itemCount: _allActivities.length,
                        itemBuilder: (context, index) {
                          final activity = _allActivities[index];
                          return ListTile(
                            title: Text(activity.description),
                            subtitle: Text(
                              '${DateFormat('yyyy-MM-dd HH:mm').format(activity.timestamp.toLocal())}\nDetails: ${activity.details}',
                            ),
                          );
                        },
                      ),
                    ),
                    actions: [
                      TextButton(
                        onPressed: () => Navigator.of(context).pop(),
                        child: const Text('Close'),
                      ),
                    ],
                  ),
                );
              },
            ),
            // Removed 'View Guest Links (Public)' as requested
            // Leaderboard
            ListTile(
              title: const Text('Leaderboard'),
              onTap: () {
                Navigator.pop(context); // Close drawer
                showDialog(
                  context: context,
                  builder: (context) => StatefulBuilder(
                    builder: (context, setInnerState) {
                      // Filter for leaderboard: only non-group students, by selected class
                      final leaderboardGroups = _allStudentGroups
                          .where((group) =>
                      (_leaderboardSelectedClass.isEmpty || group.classId == _leaderboardSelectedClass) && !group.isGroup)
                          .toList();
                      leaderboardGroups.sort((a, b) => b.score.compareTo(a.score)); // Sort by score descending

                      return AlertDialog(
                        title: const Text('Leaderboard'),
                        content: SizedBox(
                          width: double.maxFinite,
                          height: 300,
                          child: Column(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              // Class filter for leaderboard
                              DropdownButtonFormField<String>(
                                decoration: const InputDecoration(
                                  labelText: 'Filter by Class',
                                  border: OutlineInputBorder(),
                                  contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                                ),
                                value: _leaderboardSelectedClass.isEmpty ? '' : (_uniqueClassIds.contains(_leaderboardSelectedClass) ? _leaderboardSelectedClass : null),
                                items: [
                                  const DropdownMenuItem(value: '', child: Text('All Classes')),
                                  ..._uniqueClassIds.map((classId) {
                                    return DropdownMenuItem(value: classId, child: Text(classId));
                                  }).toList(),
                                ],
                                onChanged: (newValue) {
                                  if (newValue != null) {
                                    setInnerState(() { // Update dialog's internal state
                                      _leaderboardSelectedClass = newValue;
                                    });
                                  }
                                },
                              ),
                              const SizedBox(height: 16),
                              // Leaderboard list
                              Expanded(
                                child: ListView.builder(
                                  shrinkWrap: true,
                                  itemCount: leaderboardGroups.length,
                                  itemBuilder: (context, index) {
                                    final student = leaderboardGroups[index];
                                    return ListTile(
                                      leading: Text('#${index + 1}'),
                                      title: Text(student.name),
                                      trailing: Text('Score: ${student.score}'),
                                    );
                                  },
                                ),
                              ),
                            ],
                          ),
                        ),
                        actions: [
                          TextButton(
                            onPressed: () => Navigator.of(context).pop(),
                            child: const Text('Close'),
                          ),
                        ],
                      );
                    },
                  ),
                );
              },
            ),
            // Winners History
            ListTile(
              title: const Text('Winners History'),
              onTap: () {
                Navigator.pop(context); // Close drawer
                showDialog(
                  context: context,
                  builder: (context) => StatefulBuilder(
                    builder: (context, setInnerState) {
                      final sortedWinners = _sortWinners(_allWinners); // Apply sorting for winners based on selected criteria
                      return AlertDialog(
                        title: const Text('Winners History'),
                        content: SizedBox(
                          width: double.maxFinite,
                          height: 300,
                          child: Column(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              // Option to sort winners by growth
                              Row(
                                children: [
                                  const Text('Sort by Growth:'),
                                  Checkbox(
                                    value: _sortByGrowthInWinners,
                                    onChanged: (bool? value) {
                                      setInnerState(() { // Update dialog's internal state
                                        _sortByGrowthInWinners = value!;
                                      });
                                    },
                                  ),
                                ],
                              ),
                              // List of winners
                              Expanded(
                                child: ListView.builder(
                                  shrinkWrap: true,
                                  itemCount: sortedWinners.length,
                                  itemBuilder: (context, index) {
                                    final winner = sortedWinners[index];
                                    final student = _allStudentGroups.firstWhereOrNull((s) => s.id == winner.studentGroupId);
                                    String growthText = '';
                                    if (_sortByGrowthInWinners && student != null && student.history.isNotEmpty) {
                                      final growth = student.history.last.score - student.history.first.score;
                                      growthText = ' (Growth: ${growth > 0 ? '+' : ''}$growth)';
                                    }
                                    return ListTile(
                                      leading: winner.photoUrl != null && winner.photoUrl!.isNotEmpty
                                          ? CircleAvatar(
                                        backgroundImage: NetworkImage(winner.photoUrl!),
                                        onBackgroundImageError: (exception, stackTrace) {
                                          print('Error loading winner image: $exception'); // Log image loading errors
                                        },
                                      )
                                          : const CircleAvatar(child: Icon(Icons.person)), // Default icon if no image
                                      title: Text('${winner.studentGroupName} (Score: ${winner.score})'),
                                      subtitle: Text(
                                          'Declared: ${DateFormat('yyyy-MM-dd HH:mm').format(winner.timestamp.toLocal())}, Class: ${winner.classId}$growthText'),
                                      trailing: !kIsWeb // Upload photo button (mobile only)
                                          ? IconButton(
                                        icon: const Icon(Icons.upload_file),
                                        onPressed: () => _uploadWinnerPhoto(winner),
                                        tooltip: 'Upload Photo',
                                      )
                                          : null, // No upload button on web (web upload handled differently)
                                    );
                                  },
                                ),
                              ),
                            ],
                          ),
                        ),
                        actions: [
                          TextButton(
                            onPressed: () => Navigator.of(context).pop(),
                            child: const Text('Close'),
                          ),
                        ],
                      );
                    },
                  ),
                );
              },
            ),
            const Divider(),
            // Manual class filter for public data, re-purposed from guest mode dialog
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      const Text('Current Filter Class', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
                      IconButton(
                        icon: const Icon(Icons.filter_list),
                        onPressed: _showGuestModeClassIdDialog, // Re-purposed dialog for manual class ID input
                        tooltip: 'Change Class Filter',
                      ),
                    ],
                  ),
                  Text(
                    _selectedClassId.isEmpty ? 'All Classes' : _selectedClassId,
                    style: const TextStyle(fontSize: 14, color: Colors.blue),
                  ),
                  const Text(
                    'Updates the primary list filter.',
                    style: TextStyle(fontSize: 12, color: Colors.grey),
                  ),
                ],
              ),
            ),
            // Generate Shareable Report Link
            ListTile(
              title: const Text('Generate Shareable Report Link'),
              onTap: () {
                Navigator.pop(context); // Close drawer
                _generateAndShareReport();
              },
            ),
          ],
        ),
      ),
      body: Column(
        children: [
          // Row for class and type filters
          Padding(
            padding: const EdgeInsets.all(8.0),
            child: Row(
              children: [
                Expanded(
                  child: DropdownButtonFormField<String?>(
                    decoration: const InputDecoration(
                      labelText: 'Filter by Class',
                      border: OutlineInputBorder(),
                      contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                    ),
                    value: currentDropdownValue,
                    items: [
                      const DropdownMenuItem(value: '', child: Text('All Classes')),
                      ..._uniqueClassIds.map((classId) {
                        return DropdownMenuItem(value: classId, child: Text(classId));
                      }).toList(),
                    ],
                    onChanged: (String? newValue) {
                      setState(() {
                        _selectedClassId = newValue ?? '';
                        // Re-subscribe to update the list immediately with the new filter
                        _subscribeToFirestoreData();
                      });
                    },
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: DropdownButtonFormField<String>(
                    decoration: const InputDecoration(
                      labelText: 'Filter by Type',
                      border: OutlineInputBorder(),
                      contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                    ),
                    value: _entityTypeFilter,
                    items: const [
                      DropdownMenuItem(value: 'All', child: Text('All')),
                      DropdownMenuItem(value: 'Students Only', child: Text('Students Only')),
                      DropdownMenuItem(value: 'Groups Only', child: Text('Groups Only')),
                    ],
                    onChanged: (String? newValue) {
                      setState(() {
                        _entityTypeFilter = newValue ?? 'All';
                      });
                    },
                  ),
                ),
              ],
            ),
          ),
          // Horizontal list of alphabet filters
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 4.0),
            child: SizedBox(
              height: 40,
              child: ListView.builder(
                scrollDirection: Axis.horizontal,
                itemCount: alphabet.length + 1, // 'All' + A-Z
                itemBuilder: (context, index) {
                  String char;
                  if (index == 0) {
                    char = 'All';
                  } else {
                    char = alphabet[index - 1];
                  }
                  final isSelected = (_selectedAlphabetFilter == char || (char == 'All' && _selectedAlphabetFilter.isEmpty));

                  return GestureDetector(
                    onTap: () {
                      setState(() {
                        _selectedAlphabetFilter = (char == 'All') ? '' : char;
                      });
                    },
                    child: Container(
                      width: 35,
                      alignment: Alignment.center,
                      margin: const EdgeInsets.symmetric(horizontal: 2),
                      decoration: BoxDecoration(
                        color: isSelected ? Colors.lightBlue.shade200 : Colors.grey.shade200,
                        borderRadius: BorderRadius.circular(8),
                        border: Border.all(color: isSelected ? Colors.lightBlue : Colors.grey.shade300),
                      ),
                      child: Text(
                        char,
                        style: TextStyle(
                          fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                          color: isSelected ? Colors.lightBlue.shade900 : Colors.black87,
                        ),
                      ),
                    ),
                  );
                },
              ),
            ),
          ),
          // Display filtered counts
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 4.0),
            child: Align(
              alignment: Alignment.centerLeft,
              child: Text(
                'Showing $_filteredStudentsCount Students and $_filteredGroupsCount Groups',
                style: const TextStyle(fontSize: 14, fontWeight: FontWeight.bold),
              ),
            ),
          ),
          // Sort options (hidden if showing growth leaderboard)
          if (!_showGrowthLeaderboard)
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 4.0),
              child: Row(
                children: [
                  Expanded(
                    child: DropdownButtonFormField<String>(
                      decoration: const InputDecoration(
                        labelText: 'Sort by',
                        border: OutlineInputBorder(),
                        contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                      ),
                      value: _currentSortCriteria,
                      items: const [
                        DropdownMenuItem(value: 'name', child: Text('Name')),
                        DropdownMenuItem(value: 'score', child: Text('Score')),
                        DropdownMenuItem(value: 'historyCount', child: Text('History Count')),
                        DropdownMenuItem(value: 'growth', child: Text('Net Growth')),
                      ],
                      onChanged: (String? newValue) {
                        setState(() {
                          _currentSortCriteria = newValue ?? 'name';
                        });
                      },
                    ),
                  ),
                  const SizedBox(width: 8),
                  // Toggle sort order
                  IconButton(
                    icon: Icon(_sortAscending ? Icons.arrow_upward : Icons.arrow_downward),
                    onPressed: () {
                      setState(() {
                        _sortAscending = !_sortAscending;
                      });
                    },
                  ),
                ],
              ),
            ),
          // Main content area: student/group list or growth leaderboard
          Expanded(
            child: filteredGroups.isEmpty
                ? const Center(child: Text('No groups/students available for the selected filters.'))
                : RepaintBoundary( // Used for screenshot functionality
              key: _listKey,
              child: _showGrowthLeaderboard
                  ? _buildGrowthLeaderboard(filteredGroups) // Show growth leaderboard
                  : ListView.builder( // Show regular student/group list
                itemCount: filteredGroups.length,
                itemBuilder: (context, index) {
                  final item = filteredGroups[index];
                  if (item.isGroup) {
                    // UI for Group items
                    return Card(
                      margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                      elevation: 2,
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
                      child: ExpansionTile(
                        leading: const Icon(Icons.group, color: Colors.indigo),
                        title: Text(
                          '${item.name} (Group, Class: ${item.classId})',
                          style: const TextStyle(
                              fontSize: 18,
                              fontWeight: FontWeight.bold,
                              color: Colors.indigo),
                          overflow: TextOverflow.ellipsis,
                          maxLines: 1,
                        ),
                        subtitle: Text(
                          'Current Score: ${item.score}',
                          style: TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.bold,
                            color: item.score > 100
                                ? Colors.green.shade700
                                : item.score < 100
                                ? Colors.red.shade700
                                : Colors.black,
                          ),
                        ),
                        children: [
                          Padding(
                            padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                const Text('Members:', style: TextStyle(fontWeight: FontWeight.bold)),
                                if (item.memberIds != null && item.memberIds!.isNotEmpty)
                                  ...item.memberIds!.map((memberId) {
                                    final member = _allStudentGroups.firstWhereOrNull((s) => s.id == memberId);
                                    return Padding(
                                      padding: const EdgeInsets.only(left: 8.0, top: 2.0),
                                      child: Text('- ${member?.name ?? "Unknown Student"} (Score: ${member?.score ?? 'N/A'})'),
                                    );
                                  }).toList()
                                else
                                  const Text('No members in this group.'),
                                const Divider(),
                                if (item.history.isNotEmpty)
                                  Column(
                                    crossAxisAlignment: CrossAxisAlignment.start,
                                    children: [
                                      const Text('Recent Score History:', style: TextStyle(fontWeight: FontWeight.bold)),
                                      // Display history entries, coloring negative changes red
                                      // Show last 3 entries, oldest first within this section
                                      for (int i = item.history.length > 3 ? item.history.length - 3 : 0; i < item.history.length; i++)
                                        _buildHistoryEntryText(item.history[i], i > 0 ? item.history[i - 1].score : 100),
                                    ],
                                  ),
                                // Action buttons for groups
                                Align(
                                  alignment: Alignment.centerRight,
                                  child: Row(
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      ElevatedButton(
                                        onPressed: () => _showScoreUpdateDialog(item),
                                        style: ElevatedButton.styleFrom(
                                          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
                                          minimumSize: Size.zero,
                                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                                        ),
                                        child: const Text('Update Score', style: TextStyle(fontSize: 14)),
                                      ),
                                      const SizedBox(width: 8),
                                      IconButton(
                                        icon: const Icon(Icons.edit, size: 20),
                                        onPressed: () => editEntity(item),
                                        tooltip: 'Edit Group',
                                        visualDensity: VisualDensity.compact,
                                      ),
                                      IconButton(
                                        icon: const Icon(Icons.delete, size: 20),
                                        onPressed: () => deleteEntity(item.id!, item.name),
                                        tooltip: 'Delete Group',
                                        visualDensity: VisualDensity.compact,
                                      ),
                                    ],
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),
                    );
                  } else {
                    // UI for Student items
                    return Card(
                      margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                      elevation: 2,
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
                      child: Padding(
                        padding: const EdgeInsets.all(12.0),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Row(
                              mainAxisAlignment: MainAxisAlignment.spaceBetween,
                              children: [
                                Expanded(
                                  child: Text(
                                    '${item.name} (Class: ${item.classId})',
                                    style: const TextStyle(
                                        fontSize: 18,
                                        fontWeight: FontWeight.bold,
                                        color: Colors.indigo),
                                    overflow: TextOverflow.ellipsis,
                                    maxLines: 1,
                                  ),
                                ),
                                Padding(
                                  padding: const EdgeInsets.only(left: 8.0),
                                  child: ElevatedButton(
                                    onPressed: () => _showScoreUpdateDialog(item),
                                    style: ElevatedButton.styleFrom(
                                      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
                                      minimumSize: Size.zero,
                                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                                    ),
                                    child: const Text('Update Score', style: TextStyle(fontSize: 14)),
                                  ),
                                ),
                              ],
                            ),
                            const SizedBox(height: 8),
                            Text(
                              'Current Score: ${item.score}',
                              style: TextStyle(
                                fontSize: 18,
                                fontWeight: FontWeight.bold,
                                color: item.score > 100
                                    ? Colors.green.shade700
                                    : item.score < 100
                                    ? Colors.red.shade700
                                    : Colors.black,
                              ),
                            ),
                            if (item.history.isNotEmpty)
                              Padding(
                                padding: const EdgeInsets.only(top: 8.0),
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children:
                                  // Display history entries, coloring negative changes red
                                  // Show last 3 entries, oldest first within this section
                                  (item.history.length > 3 ? item.history.sublist(item.history.length - 3) : item.history)
                                      .map((entry) {
                                    final int indexInFullHistory = item.history.indexOf(entry);
                                    return _buildHistoryEntryText(entry, indexInFullHistory > 0 ? item.history[indexInFullHistory - 1].score : 100);
                                  }).toList(),
                                ),
                              ),
                            Align(
                              alignment: Alignment.centerRight,
                              child: Row(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  IconButton(
                                    icon: const Icon(Icons.edit, size: 20),
                                    onPressed: () => editEntity(item),
                                    tooltip: 'Edit Student',
                                    visualDensity: VisualDensity.compact,
                                  ),
                                  IconButton(
                                    icon: const Icon(Icons.delete, size: 20),
                                    onPressed: () => deleteEntity(item.id!, item.name),
                                    tooltip: 'Delete Student',
                                    visualDensity: VisualDensity.compact,
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ),
                    );
                  }
                },
              ),
            ),
          ),
          // Message display at the bottom, fades out after a few seconds
          if (_message.isNotEmpty)
            Container(
              width: double.infinity,
              padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
              color: _message.contains('Error') ? Colors.red.shade700 : Colors.green.shade700,
              child: Text(
                _message,
                style: const TextStyle(
                  color: Colors.white,
                  fontWeight: FontWeight.bold,
                ),
                textAlign: TextAlign.center,
                overflow: TextOverflow.ellipsis,
                maxLines: 2,
              ),
            ),
        ],
      ),
    );
  }

  /// Helper function to build a single score history entry text with dynamic coloring.
  Widget _buildHistoryEntryText(ScoreHistoryEntry entry, int previousScore) {
    final int scoreChange = entry.score - previousScore;
    final Color textColor = scoreChange < 0 ? Colors.red.shade700 : Colors.black;

    final now = DateTime.now();
    final ts = entry.timestamp.toLocal();
    String timeString = TimeOfDay.fromDateTime(ts).format(context);
    String dateString = (ts.day == now.day && ts.month == now.month && ts.year == now.year)
        ? "today"
        : DateFormat('dd/MM/yyyy').format(ts);
    String reasonText = entry.reason != null && entry.reason!.isNotEmpty ? 'Reason: ${entry.reason}' : '';
    String commentText = entry.customComment != null && entry.customComment!.isNotEmpty ? 'Comment: ${entry.customComment}' : '';
    String separator = (reasonText.isNotEmpty && commentText.isNotEmpty) ? ', ' : '';

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2),
      child: Text(
          "Score: ${entry.score} (Change: ${scoreChange > 0 ? '+' : ''}$scoreChange), Time: $timeString $dateString"
              "${reasonText.isNotEmpty ? ', $reasonText' : ''}"
              "${commentText.isNotEmpty ? '$separator$commentText' : ''}",
          style: TextStyle(fontSize: 13, color: textColor)),
    );
  }

  /// Builds the growth leaderboard display.
  /// This shows students/groups with the most positive and most negative net score changes.
  Widget _buildGrowthLeaderboard(List<StudentGroup> items) {
    // Calculate net growth for all items
    List<Map<String, dynamic>> growthData = items.map((item) {
      // Initial score is the first entry in history, or current score if history is empty
      final int initialScore = item.history.isNotEmpty ? item.history.first.score : item.score;
      final int netGrowth = item.score - initialScore; // Current score minus initial score

      int totalIncrement = 0;
      int totalDecrement = 0;

      // Calculate total increments and decrements from history
      for (int i = 1; i < item.history.length; i++) {
        final change = item.history[i].score - item.history[i-1].score;
        if (change > 0) {
          totalIncrement += change;
        } else if (change < 0) {
          totalDecrement += change.abs();
        }
      }
      return {
        'item': item,
        'netGrowth': netGrowth,
        'totalIncrement': totalIncrement,
        'totalDecrement': totalDecrement,
      };
    }).toList();

    // Separate into positive, negative, and zero growth lists
    List<Map<String, dynamic>> positiveGrowth = growthData.where((data) => data['netGrowth'] > 0).toList();
    List<Map<String, dynamic>> negativeGrowth = growthData.where((data) => data['netGrowth'] < 0).toList();
    List<Map<String, dynamic>> zeroGrowth = growthData.where((data) => data['netGrowth'] == 0).toList();

    // Sort positive growth descending (highest growth first)
    positiveGrowth.sort((a, b) => b['netGrowth'].compareTo(a['netGrowth']));
    // Sort negative growth ascending (most negative first, e.g., -50 before -10)
    negativeGrowth.sort((a, b) => a['netGrowth'].compareTo(b['netGrowth']));
    // Sort zero growth by name alphabetically
    zeroGrowth.sort((a, b) => (a['item'] as StudentGroup).name.compareTo((b['item'] as StudentGroup).name));

    // Get top 5 from positive growth and top 5 (most negative) from negative growth
    List<Map<String, dynamic>> top5Positive = positiveGrowth.take(5).toList();
    List<Map<String, dynamic>> top5Negative = negativeGrowth.take(5).toList(); // These are the "most decremented"

    // Combine all remaining items (zero growth and those not in top/bottom 5)
    Set<String> excludedIds = {};
    top5Positive.forEach((data) => excludedIds.add((data['item'] as StudentGroup).id!));
    top5Negative.forEach((data) => excludedIds.add((data['item'] as StudentGroup).id!));

    List<Map<String, dynamic>> otherStudents = growthData.where((data) => !excludedIds.contains((data['item'] as StudentGroup).id!)).toList();
    otherStudents.sort((a, b) => (a['item'] as StudentGroup).name.compareTo((b['item'] as StudentGroup).name));


    return Column(
      children: [
        Padding(
          padding: const EdgeInsets.all(8.0),
          child: Text(
            'Growth Leaderboard (Class: ${_selectedClassId.isEmpty ? "All" : _selectedClassId})',
            style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
        ),
        Expanded(
          child: ListView(
            children: [
              if (top5Positive.isNotEmpty) ...[
                const Padding(
                  padding: EdgeInsets.symmetric(horizontal: 8.0, vertical: 4.0),
                  child: Text('Top 5 Most Improved (Green)', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold, color: Colors.green)),
                ),
                ...top5Positive.map((data) => _buildGrowthCard(data, Colors.green.shade100)).toList(),
                const Divider(),
              ],
              if (top5Negative.isNotEmpty) ...[
                const Padding(
                  padding: EdgeInsets.symmetric(horizontal: 8.0, vertical: 4.0),
                  child: Text('Top 5 Most Decreased (Red)', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold, color: Colors.red)),
                ),
                // Displaying most decremented in ascending order (most negative first)
                ...top5Negative.map((data) => _buildGrowthCard(data, Colors.red.shade100)).toList(),
                const Divider(),
              ],
              if (otherStudents.isNotEmpty) ...[
                const Padding(
                  padding: EdgeInsets.symmetric(horizontal: 8.0, vertical: 4.0),
                  child: Text('Other Students/Groups', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
                ),
                ...otherStudents.map((data) => _buildGrowthCard(data, Colors.white)).toList(),
              ],
              if (top5Positive.isEmpty && top5Negative.isEmpty && otherStudents.isEmpty)
                const Center(child: Text('No growth data available for the selected filters.')),
            ],
          ),
        ),
      ],
    );
  }

  /// Helper widget to build a single growth card for the leaderboard.
  Widget _buildGrowthCard(Map<String, dynamic> data, Color? cardColor) {
    final StudentGroup item = data['item'];
    final int netGrowth = data['netGrowth'];
    final int totalIncrement = data['totalIncrement'];
    final int totalDecrement = data['totalDecrement'];
    final int initialScore = item.history.isNotEmpty ? item.history.first.score : item.score;

    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      color: cardColor,
      elevation: 1,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      child: Padding(
        padding: const EdgeInsets.all(12.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              '${item.name} (${item.isGroup ? "Group" : "Student"}) (Class: ${item.classId})',
              style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 4),
            Text('Current Score: ${item.score}'),
            Text('Initial Score: ${initialScore}'),
            Text('Net Growth: ${netGrowth > 0 ? '+' : ''}$netGrowth', style: TextStyle(color: netGrowth > 0 ? Colors.green.shade800 : netGrowth < 0 ? Colors.red.shade800 : Colors.black)),
            Text('Total Increment: ${totalIncrement}'),
            Text('Total Decrement: ${totalDecrement}'),
          ],
        ),
      ),
    );
  }
}